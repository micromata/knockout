<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>template</title>
  <meta name="description" content="It&#x27;s about saying »Hello« to the world.">
	<link rel="stylesheet" href="/assets/css/code.css">
</head>
<body>
  <header>
    <p>
      <a href="/">Home</a>
    </p>
  </header>
  <h1>template</h1>

  <h3 id="purpose">Purpose</h3>
<p>The <code class="lang-cpp"><span class="hljs-keyword">template</span></code> binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.</p>
<p>There are two main ways of using templates:</p>
<ul>
<li><em>Native templating</em> is the mechanism that underpins <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code>, <code class="lang-actionscript"><span class="hljs-keyword">if</span></code>, <code class="lang-actionscript"><span class="hljs-keyword">with</span></code>, and other control flow bindings. Internally, those control
flow bindings capture the HTML markup contained in your element, and use it as a template to render against an arbitrary data item.
This feature is built into Knockout and doesn't require any external library.</li>
<li><em>String-based templating</em> is a way to connect Knockout to a third-party template engine. Knockout will pass your model values to
the external template engine and inject the resulting markup string into your document. See below for examples that use the <em>jquery.tmpl</em>
and <em>Underscore</em> template engines.</li>
</ul>
<h3 id="parameters">Parameters</h3>
<ul>
<li><p>Main parameter</p>
<ul>
<li><p>Shorthand syntax: If you just supply a string value, KO will interpret this as the ID of a template to render. The data it supplies to the template will be your current model object.</p>
</li>
<li><p>For more control, pass a JavaScript object with some combination of the following properties:</p>
<ul>
<li><code class="lang-applescript"><span class="hljs-property">name</span></code> --- the ID of an element that contains the template you wish to render - see <a href="#note_5_dynamically_choosing_which_template_is_used">Note 5</a> for how to vary this programmatically.</li>
<li><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span></span></code> --- an object to supply as the data for the template to render. If you omit this parameter, KO will look for a <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> parameter, or will fall back on using your current model object.</li>
<li><code class="lang-actionscript"><span class="hljs-keyword">if</span></code> --- if this parameter is provided, the template will only be rendered if the specified expression evaluates to <code class="lang-actionscript"><span class="hljs-literal">true</span></code> (or a <code class="lang-actionscript"><span class="hljs-literal">true</span></code>-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.</li>
<li><code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> --- instructs KO to render the template in "foreach" mode - see <a href="#note_2_using_the_foreach_option_with_a_named_template">Note 2</a> for details.</li>
<li><code class="lang-actionscript"><span class="hljs-keyword">as</span></code> --- when used in conjunction with <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code>, defines an alias for each item being rendered - see <a href="#note_3_using_as_to_give_an_alias_to_foreach_items">Note 3</a> for details.</li>
<li><code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Render</span></code>, <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Add</span></code>, or <code>beforeRemove</code> --- callback functions to be invoked against the rendered DOM elements - see <a href="#note_4_using_afterrender_afteradd_and_beforeremove">Note 4</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="note-1-rendering-a-named-template">Note 1: Rendering a named template</h3>
<p>Normally, when you're using control flow bindings (<code class="lang-cmake"><span class="hljs-keyword">foreach</span></code>, <code class="lang-actionscript"><span class="hljs-keyword">with</span></code>, <code class="lang-actionscript"><span class="hljs-keyword">if</span></code>, etc.), there's no need to give names to your templates: they are defined implicitly
and anonymously by the markup inside your DOM element. But if you want to, you can factor out templates into a separate element and then reference them by name:</p>
<pre><code class="lang-javascript">html: |-
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>Participants<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
  Here are the participants:
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"template: { name: 'person-template', data: buyer }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"template: { name: 'person-template', data: seller }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'person-template'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">h3</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Credits: <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: credits"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>

javascript: |-
     function MyViewModel() {
         this.buyer = { name: 'Franklin', credits: 250 };
         this.seller = { name: 'Mario', credits: 5800 };
     }
     ko.applyBindings(new MyViewModel());
</span></code></pre>
<p>In this example, the <code class="lang-cpp">person-<span class="hljs-keyword">template</span></code> markup is used twice: once for <code>buyer</code>, and once for <code>seller</code>. Notice that the template markup is wrapped in a <code class="lang-fsharp">script <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"text/html"</span></code> ---
the dummy <code class="lang-elm"><span class="hljs-typedef"><span class="hljs-keyword">type</span></span></code> attribute is necessary to ensure that the markup is not executed as JavaScript, and Knockout does not attempt to apply
bindings to that markup except when it is being used as a template.</p>
<p>It's not very often that you'll need to use named templates, but on occasion it can help to minimise duplication of markup.</p>
<h3 id="note-2-using-the-foreach-option-with-a-named-template">Note 2: Using the "foreach" option with a named template</h3>
<p>If you want the equivalent of a <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding, but using a named template, you can do so in the natural way:</p>
<pre><code class="lang-javascript">html: |-
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>Participants<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
  Here are the participants:
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"template: { name: 'person-template', foreach: people }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'person-template'</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">'text/x-knockout'</span>&gt;</span><span class="handlebars"><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">h3</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Credits: <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: credits"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
  </span></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
javascript: |-
  function MyViewModel() {
    this.people = [
      { name: 'Franklin', credits: 250 },
      { name: 'Mario', credits: 5800 }
    ]
  }
  ko.applyBindings(new MyViewModel());
</span></code></pre>
<p>This gives the same result as embedding an anonymous template directly inside the element to which you use <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code>, i.e.:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"foreach: people"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">h3</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Credits: <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: credits"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<h3 id="note-3-using-as-to-give-an-alias-to-foreach-items">Note 3: Using "as" to give an alias to "foreach" items</h3>
<p>When nesting <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> templates, it's often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to <code class="lang-xquery"><span class="hljs-variable">$parent</span></code> or other <a href="binding-context.html">binding context</a> variables in your bindings.</p>
<p>A simpler and more elegant option, however, is to use <code class="lang-actionscript"><span class="hljs-keyword">as</span></code> to declare a name for your iteration variables. For example:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"template: { name: 'employeeTemplate',
                                  foreach: employees,
                                  as: 'employee' }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p>Notice the string value <code class="lang-actionscript"><span class="hljs-string">'employee'</span></code> associated with <code class="lang-actionscript"><span class="hljs-keyword">as</span></code>. Now anywhere inside this <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> loop, bindings in your child templates will be able to refer to <code>employee</code> to access the employee object being rendered.</p>
<p>This is mainly useful if you have multiple levels of nested <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here's a complete example, showing how <code>season</code> can be referenced while rendering a <code class="lang-applescript"><span class="hljs-property">month</span></code>:</p>
<pre><code class="lang-javascript">html: |-
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"template: { name: 'seasonTemplate', foreach: seasons, as: 'season' }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
  <span class="hljs-comment">&lt;!--  (Note that you can, and probably should, use the `template` binding for newer browsers) --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">strong</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">strong</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"template: { name: 'monthTemplate', foreach: months, as: 'month' }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'monthTemplate'</span>&gt;</span><span class="handlebars"><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: month"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
        is in
        <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: season.name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
  </span></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>

javascript: |-
  var viewModel = {
      seasons: ko.observableArray([
          { name: 'Spring', months: [ 'March', 'April', 'May' ] },
          { name: 'Summer', months: [ 'June', 'July', 'August' ] },
          { name: 'Autumn', months: [ 'September', 'October', 'November' ] },
          { name: 'Winter', months: [ 'December', 'January', 'February' ] }
      ])
  };
  ko.applyBindings(viewModel);
</span></code></pre>
<p>Tip: Remember to pass a <em>string literal value</em> to as (e.g., <code class="lang-actionscript"><span class="hljs-keyword">as</span>: <span class="hljs-string">'season'</span></code>, <em>not</em> <code class="lang-http"><span class="hljs-attribute">as</span>: <span class="hljs-string">season</span></code>), because you are giving a name for a new variable, not reading the value of a variable that already exists.</p>
<h3 id="note-4-using-afterrender-afteradd-and-beforeremove-">Note 4: Using "afterRender", "afterAdd", and "beforeRemove"</h3>
<p>Sometimes you might want to run custom post-processing logic on the DOM elements generated by your templates. For example, if you're using a JavaScript widgets library such as jQuery UI, you might want to intercept your templates' output so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.</p>
<p>Generally, the best way to perform such post-processing on DOM elements is to write a <a href="custom-bindings.html">custom binding</a>, but if you really just want to access the raw DOM elements emitted by a template, you can use <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Render</span></code>.</p>
<p>Pass a function reference (either a function literal, or give the name of a function on your view model), and Knockout will invoke it immediately after rendering or re-rendering your template. If you're using <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code>, Knockout will invoke your <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Render</span></code> callback for each item added to your observable array. For example,</p>
<pre><code class="lang-html">  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">'template: { name: "personTemplate",
                              data: myData,
                              afterRender: myPostProcessingLogic }'</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>... and define a corresponding function on your view model (i.e., the object that contains <code>myData</code>):</p>
<pre><code class="lang-javascript">viewModel.myPostProcessingLogic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elements</span>) </span>{
    <span class="hljs-comment">// "elements" is an array of DOM nodes just rendered by the template</span>
    <span class="hljs-comment">// You can add custom post-processing logic here</span>
}
</code></pre>
<p>If you are using <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> and only want to be notified about elements that are specifically being added or are being removed, you can use <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Add</span></code> and <code>beforeRemove</code> instead. For details, see documentation for the <a href="foreach-binding.html"><code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding</a>.</p>
<h3 id="note-5-dynamically-choosing-which-template-is-used">Note 5: Dynamically choosing which template is used</h3>
<p>If you have multiple named templates, you can pass an observable for the <code class="lang-applescript"><span class="hljs-property">name</span></code> option. As the observable's value is updated, the element's contents will be re-rendered using the appropriate template. Alternatively, you can pass a callback function to determine which template to use. If you are using the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> template mode, Knockout will evaluate the function for each item in your array, passing that item's value as the only argument. Otherwise, the function will be given the <code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span></span></code> option's value or fall back to providing your whole current model object.</p>
<p>For example,</p>
<pre><code class="lang-javascript">html: |-
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">'template: { name: displayMode,
                               foreach: employees }'</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
javascript: |-
    var viewModel = {
        employees: ko.observableArray([
            { name: "Kari", active: ko.observable(true) },
            { name: "Brynn", active: ko.observable(false) },
            { name: "Nora", active: ko.observable(false) }
        ]),
        displayMode: function(employee) {
            // Initially "Kari" uses the "active" template, while the others use "inactive"
            return employee.active() ? "active" : "inactive";
        }
    };

    // ... then later ...
    viewModel.employees()[1].active(true); // Now "Brynn" is also rendered using the "active" template.
</span></code></pre>
<p>If your function references observable values, then the binding will update whenever any of those values change.  This will cause the data to be re-rendered using the appropriate template.</p>
<p>If your function accepts a second parameter, then it will receive the entire <a href="binding-context.html">binding context</a>. You can then access <code class="lang-xquery"><span class="hljs-variable">$parent</span></code> or any other <a href="binding-context.html">binding context</a> variable when dynamically choosing a template. For example, you could amend the preceding code snippet as follows:</p>
<pre><code class="lang-javascript">displayMode: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">employee, bindingContext</span>) </span>{
    <span class="hljs-comment">// Now return a template name string based on properties of employee or bindingContext</span>
}
</code></pre>
<h3 id="note-6-using-jquery-tmpl-an-external-string-based-template-engine">Note 6: Using jQuery.tmpl, an external string-based template engine</h3>
<p>In the vast majority of cases, Knockout's native templating and the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code>, <code class="lang-actionscript"><span class="hljs-keyword">if</span></code>, <code class="lang-actionscript"><span class="hljs-keyword">with</span></code> and other control flow bindings will be all you need to construct an arbitrarily sophisticated UI. But in case you wish to integrate with an external templating library, such as the <a href="http://documentcloud.github.com/underscore/#template">Underscore template engine</a> or <a href="http://api.jquery.com/jquery.tmpl/">jquery.tmpl</a>, Knockout offers a way to do it.</p>
<p>By default, Knockout comes with support for <a href="http://api.jquery.com/jquery.tmpl/">jquery.tmpl</a>. To use it, you need to reference the following libraries, in this order:</p>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- First jQuery --&gt;</span>     script src="http://code.jquery.com/jquery-1.7.1.min.js"
<span class="hljs-comment">&lt;!-- Then jQuery.tmpl --&gt;</span> script src="jquery.tmpl.js"
<span class="hljs-comment">&lt;!-- Then Knockout --&gt;</span>    script src="knockout-x.y.z.js"
</code></pre>
<p>Then, you can use jQuery.tmpl syntax in your templates. For example,</p>
<pre><code class="lang-javascript">html: |-
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>People<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"template: 'peopleList'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'peopleList'</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- FIXME --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">p</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">'foreach: $data'</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">b</span>&gt;</span>${name}<span class="hljs-tag">&lt;/<span class="hljs-title">b</span>&gt;</span> is ${age} years old
      <span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
javascript: |-
    var viewModel = {
        people: ko.observableArray([
            { name: 'Rod', age: 123 },
            { name: 'Jane', age: 125 },
        ])
    }
    ko.applyBindings(viewModel);
</span></code></pre>
<p>This works because <code class="lang-crystal"><span class="hljs-expansion">{{<span class="hljs-string">'{{'</span>}}</span>each ...}}</code> and <code class="lang-bash"><span class="hljs-variable">${ ... }</span></code> are jQuery.tmpl syntaxes. What's more, it's trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a <code class="lang-fortran"><span class="hljs-type">data</span>-<span class="hljs-keyword">bind</span>=<span class="hljs-string">"template: ..."</span></code> inside a template to render a nested one.</p>
<p>Please note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout's native DOM-based templating (i.e., the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code>, <code class="lang-actionscript"><span class="hljs-keyword">if</span></code>, <code class="lang-actionscript"><span class="hljs-keyword">with</span></code>, etc. bindings) instead of jQuery.tmpl or any other string-based template engine.</p>
<h3 id="note-7-using-the-underscore-js-template-engine">Note 7: Using the Underscore.js template engine</h3>
<p>The <a href="http://documentcloud.github.com/underscore/#template">Underscore.js template engine</a> by default uses ERB-style delimiters (<code class="lang-gcode">&lt;<span class="hljs-preprocessor">%</span>= ... <span class="hljs-preprocessor">%</span>&gt;</code>). Here's how the preceding example's template might look with Underscore:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'peopleList'</span>&gt;</span><span class="handlebars"><span class="xml">
    <span class="hljs-tag">&lt;<span class="hljs-title">%</span> <span class="hljs-attribute">_.each</span>(<span class="hljs-attribute">people</span>(), <span class="hljs-attribute">function</span>(<span class="hljs-attribute">person</span>) { %&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">%=</span> <span class="hljs-attribute">person.name</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">b</span>&gt;</span> is <span class="hljs-tag">&lt;<span class="hljs-title">%=</span> <span class="hljs-attribute">person.age</span> %&gt;</span> years old
        <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">%</span> }) %&gt;</span>
</span></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Here's <a href="http://jsfiddle.net/rniemeyer/NW5Vn/">a simple implementation of integrating Underscore templates with Knockout</a>. The integration code is just 16 lines long, but it's enough to support Knockout <code class="lang-fortran"><span class="hljs-type">data</span>-<span class="hljs-keyword">bind</span></code> attributes (and hence nested templates) and Knockout <a href="binding-context.html">binding context</a> variables (<code class="lang-xquery"><span class="hljs-variable">$parent</span></code>, <code class="lang-xquery"><span class="hljs-variable">$root</span></code>, etc.).</p>
<p>If you're not a fan of the <code class="lang-gcode">&lt;<span class="hljs-preprocessor">%</span>= ... <span class="hljs-preprocessor">%</span>&gt;</code> delimiters, you can configure the Underscore template engine to use any other delimiter characters of your choice.</p>
<h3 id="dependencies">Dependencies</h3>
<ul>
<li><strong>Native templating</strong> does not require any library other than Knockout itself</li>
<li><strong>String-based templating</strong> works only once you've referenced a suitable template engine, such as jQuery.tmpl or the Underscore template engine.</li>
</ul>


  <footer>
    <p>Generated with Metalsmith &mdash; <a href="http://metalsmith.io">http://metalsmith.io</a></p>
  </footer>

</body>
</html>
