<p>  Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout&#39;s core value types. You can define custom functions on any of the following types:</p>
<p>  TODO: HIERARCHY
  <img src="images/fn/type-hierarchy.png" alt=""></p>
<p>  Because of inheritance, if you attach a function to <code>ko.subscribable</code>, it will be available on all the others too. If you attach a function to <code>ko.observable</code>, it will be inherited by <code>ko.observableArray</code> but not by <code>ko.computed</code>.</p>
<p>  To attach a custom function, add it to one of the following extensibility points:</p>
<ul>
<li><code>ko.subscribable.fn</code></li>
<li><code>ko.observable.fn</code></li>
<li><code>ko.observableArray.fn</code></li>
<li><code>ko.computed.fn</code></li>
</ul>
<p>  Then, your custom function will become available on all values of that type created from that point onwards.</p>
<p>  <strong><em>Note:</em></strong> It&#39;s best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don&#39;t need to add a custom function to these namespaces if you&#39;re only planning to use it once.</p>
<h3 id="example-a-filtered-view-of-an-observable-array">Example: A filtered view of an observable array</h3>
<p>  Here&#39;s a way to define a <code>filterByProperty</code> function that will become available on all subsequently-created <code>ko.observableArray</code> instances:</p>
<pre><code class="lang-javascript">ko.observableArray.fn.filterByProperty = function(propName, matchValue) {
    return ko.computed(function() {
        var allItems = this(), matchingItems = [];
        for (var i = 0; i &lt; allItems.length; i++) {
            var current = allItems[i];
            if (ko.unwrap(current[propName]) === matchValue)
                matchingItems.push(current);
        }
        return matchingItems;
    }, this);
}
</code></pre>
<p>  This returns a new <code>ko.computed</code> value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a <code>ko.computed</code>, it will be re-evaluated automatically whenever the underlying array changes.</p>
<p>  The following live example shows how you could use this:</p>
<pre><code class="lang-javascript">ko.observableArray.fn.filterByProperty = function(propName, matchValue) {
    return ko.computed(function() {
        var allItems = this(), matchingItems = [];
        for (var i = 0; i &lt; allItems.length; i++) {
            var current = allItems[i];
            if (ko.unwrap(current[propName]) === matchValue)
                matchingItems.push(current);
        }
        return matchingItems;
    }, this);
}
</code></pre>
<pre><code class="lang-html">&lt;h3&gt;All tasks (&lt;span data-bind=&quot;text: tasks().length&quot;&gt; &lt;/span&gt;)&lt;/h3&gt;
&lt;ul data-bind=&quot;foreach: tasks&quot;&gt;
    &lt;li&gt;
        &lt;label&gt;
            &lt;input type=&quot;checkbox&quot; data-bind=&quot;checked: done&quot; /&gt;
            &lt;span data-bind=&quot;text: title&quot;&gt; &lt;/span&gt;
        &lt;/label&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Done tasks (&lt;span data-bind=&quot;text: doneTasks().length&quot;&gt; &lt;/span&gt;)&lt;/h3&gt;
&lt;ul data-bind=&quot;foreach: doneTasks&quot;&gt;
    &lt;li data-bind=&quot;text: title&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="lang-javascript">function Task(title, done) {
    this.title = ko.observable(title);
    this.done = ko.observable(done);
}

function AppViewModel() {
    this.tasks = ko.observableArray([
        new Task(&#39;Find new desktop background&#39;, true),
        new Task(&#39;Put shiny stickers on laptop&#39;, false),
        new Task(&#39;Request more reggae music in the office&#39;, true)
    ]);
    // Here&#39;s where we use the custom function
    this.doneTasks = this.tasks.filterByProperty(&quot;done&quot;, true);
}

ko.applyBindings(new AppViewModel());
</code></pre>
<h4 id="it-s-not-mandatory">It&#39;s not mandatory</h4>
<p>  If you tend to filter observable arrays a lot, adding a <code>filterByProperty</code> globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose <em>not</em> to attach to <code>ko.observableArray.fn</code>, and instead just construct <code>doneTasks</code> by hand as follows:</p>
<pre><code class="lang-javascript">this.doneTasks = ko.computed(function() {
    var all = this.tasks(), done = [];
    for (var i = 0; i &lt; all.length; i++)
        if (all[i].done())
            done.push(all[i]);
    return done;
}, this);
</code></pre>
