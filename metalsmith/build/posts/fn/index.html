<p>  Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout's core value types. You can define custom functions on any of the following types:</p>
<p>  TODO: HIERARCHY
  <img src="images/fn/type-hierarchy.png" alt=""></p>
<p>  Because of inheritance, if you attach a function to <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.subscribable</span></code>, it will be available on all the others too. If you attach a function to <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.observable</span></code>, it will be inherited by <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.observableArray</span></code> but not by <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computed</span></code>.</p>
<p>  To attach a custom function, add it to one of the following extensibility points:</p>
<ul>
<li><code class="lang-stylus">ko<span class="hljs-class">.subscribable</span><span class="hljs-class">.fn</span></code></li>
<li><code class="lang-stylus">ko<span class="hljs-class">.observable</span><span class="hljs-class">.fn</span></code></li>
<li><code class="lang-stylus">ko<span class="hljs-class">.observableArray</span><span class="hljs-class">.fn</span></code></li>
<li><code class="lang-stylus">ko<span class="hljs-class">.computed</span><span class="hljs-class">.fn</span></code></li>
</ul>
<p>  Then, your custom function will become available on all values of that type created from that point onwards.</p>
<p>  <strong><em>Note:</em></strong> It's best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don't need to add a custom function to these namespaces if you're only planning to use it once.</p>
<h3 id="example-a-filtered-view-of-an-observable-array">Example: A filtered view of an observable array</h3>
<p>  Here's a way to define a <code>filterByProperty</code> function that will become available on all subsequently-created <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.observableArray</span></code> instances:</p>
<pre><code class="lang-javascript">ko.observableArray.fn.filterByProperty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">propName, matchValue</span>) </span>{
    <span class="hljs-keyword">return</span> ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> allItems = <span class="hljs-keyword">this</span>(), matchingItems = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; allItems.length; i++) {
            <span class="hljs-keyword">var</span> current = allItems[i];
            <span class="hljs-keyword">if</span> (ko.unwrap(current[propName]) === matchValue)
                matchingItems.push(current);
        }
        <span class="hljs-keyword">return</span> matchingItems;
    }, <span class="hljs-keyword">this</span>);
}
</code></pre>
<p>  This returns a new <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computed</span></code> value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computed</span></code>, it will be re-evaluated automatically whenever the underlying array changes.</p>
<p>  The following live example shows how you could use this:</p>
<pre><code class="lang-javascript">ko.observableArray.fn.filterByProperty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">propName, matchValue</span>) </span>{
    <span class="hljs-keyword">return</span> ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> allItems = <span class="hljs-keyword">this</span>(), matchingItems = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; allItems.length; i++) {
            <span class="hljs-keyword">var</span> current = allItems[i];
            <span class="hljs-keyword">if</span> (ko.unwrap(current[propName]) === matchValue)
                matchingItems.push(current);
        }
        <span class="hljs-keyword">return</span> matchingItems;
    }, <span class="hljs-keyword">this</span>);
}
</code></pre>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">h3</span>&gt;</span>All tasks (<span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: tasks().length"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>)<span class="hljs-tag">&lt;/<span class="hljs-title">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"foreach: tasks"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"checkbox"</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"checked: done"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: title"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">h3</span>&gt;</span>Done tasks (<span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: doneTasks().length"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>)<span class="hljs-tag">&lt;/<span class="hljs-title">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"foreach: doneTasks"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Task</span>(<span class="hljs-params">title, done</span>) </span>{
    <span class="hljs-keyword">this</span>.title = ko.observable(title);
    <span class="hljs-keyword">this</span>.done = ko.observable(done);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AppViewModel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.tasks = ko.observableArray([
        <span class="hljs-keyword">new</span> Task(<span class="hljs-string">'Find new desktop background'</span>, <span class="hljs-literal">true</span>),
        <span class="hljs-keyword">new</span> Task(<span class="hljs-string">'Put shiny stickers on laptop'</span>, <span class="hljs-literal">false</span>),
        <span class="hljs-keyword">new</span> Task(<span class="hljs-string">'Request more reggae music in the office'</span>, <span class="hljs-literal">true</span>)
    ]);
    <span class="hljs-comment">// Here's where we use the custom function</span>
    <span class="hljs-keyword">this</span>.doneTasks = <span class="hljs-keyword">this</span>.tasks.filterByProperty(<span class="hljs-string">"done"</span>, <span class="hljs-literal">true</span>);
}

ko.applyBindings(<span class="hljs-keyword">new</span> AppViewModel());
</code></pre>
<h4 id="it-s-not-mandatory">It's not mandatory</h4>
<p>  If you tend to filter observable arrays a lot, adding a <code>filterByProperty</code> globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose <em>not</em> to attach to <code class="lang-stylus">ko<span class="hljs-class">.observableArray</span><span class="hljs-class">.fn</span></code>, and instead just construct <code class="lang-bash"><span class="hljs-keyword">done</span>Tasks</code> by hand as follows:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.doneTasks = ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> all = <span class="hljs-keyword">this</span>.tasks(), done = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; all.length; i++)
        <span class="hljs-keyword">if</span> (all[i].done())
            done.push(all[i]);
    <span class="hljs-keyword">return</span> done;
}, <span class="hljs-keyword">this</span>);
</code></pre>
