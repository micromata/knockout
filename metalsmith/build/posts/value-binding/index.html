<p><em>Note: The <a href="#textInput-binding"><code>textInput</code></a> binding can be used in many places instead of the <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> binding, providing broader support for many edge
  cases and textInput update the observables on a per-character change (as opposed to the default of <code>blur</code> for the <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> binding).</em></p>
<h3 id="purpose">Purpose</h3>
<p>The <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> binding links the associated DOM element's value with a property on your view model. This is typically useful with form elements such as <code class="lang-apache"><span class="hljs-tag">&lt;input&gt;</span></code>, <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> and <code class="lang-apache"><span class="hljs-tag">&lt;textarea&gt;</span></code>.</p>
<p>When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.</p>
<p>Note: If you're working with checkboxes or radio buttons, use <a href="checked-binding.html">the <code class="lang-cs"><span class="hljs-keyword">checked</span></code> binding</a> to read and write your element's checked state, not the <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> binding.</p>
<h3 id="example">Example</h3>
<p><live-example params="id: &quot;value-binding&quot;"></live-example></p>
<h3 id="parameters">Parameters</h3>
<ul>
<li><p>Main parameter</p>
<p>KO sets the element's <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> property to your parameter value. Any previous value will be overwritten.</p>
<p>If this parameter is an observable value, the binding will update the element's value whenever the value changes. If the parameter isn't observable, it will only set the element's value once and will not update it again later.</p>
<p>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to <code class="lang-stylus">yourParameter.<span class="hljs-function"><span class="hljs-title">toString</span><span class="hljs-params">()</span></span></code> (that's usually not very useful, so it's best to supply string or numeric values).</p>
<p>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the <code class="lang-sql"><span class="hljs-operator"><span class="hljs-keyword">change</span></span></code> event), but you can also trigger updates based on other events by using the <code>valueUpdate</code> parameter described below.</p>
</li>
<li><p>Additional parameters</p>
<ul>
<li><p><code>valueUpdate</code></p>
<p>If your binding also includes a parameter called <code>valueUpdate</code>, this defines additional browser events KO should use to detect changes besides the <code class="lang-sql"><span class="hljs-operator"><span class="hljs-keyword">change</span></span></code> event. The following string values are the most commonly useful choices:</p>
<ul>
<li><code class="lang-1c"><span class="hljs-string">"input"</span></code> - updates your view model when the value of an <code class="lang-apache"><span class="hljs-tag">&lt;input&gt;</span></code> or <code class="lang-apache"><span class="hljs-tag">&lt;textarea&gt;</span></code> element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).</li>
<li><code class="lang-1c"><span class="hljs-string">"keyup"</span></code> - updates your view model when the user releases a key</li>
<li><code class="lang-1c"><span class="hljs-string">"keypress"</span></code> - updates your view model when the user has typed a key. Unlike <code>keyup</code>, this updates repeatedly while the user holds a key down</li>
<li><code class="lang-1c"><span class="hljs-string">"afterkeydown"</span></code> - updates your view model as soon as the user begins typing a character. This works by catching the browser's <code>keydown</code> event and handling the event asynchronously.</li>
</ul>
<p>Of these options, <code class="lang-1c"><span class="hljs-string">"input"</span></code> is the best choice if you want to keep your view model updated in real-time, and you only need to support reasonably modern browsers such as IE 9+ (whereas <code class="lang-1c"><span class="hljs-string">"afterkeydown"</span></code> is a good choice for older browsers). For example:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Your value: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"value: someValue, valueUpdate: 'input'"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>You have typed: <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: someValue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- updates in real-time --&gt;</span>
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> viewModel = {
   someValue: ko.observable(<span class="hljs-string">"edit me"</span>)
};
</code></pre>
<ul>
<li><p><code>valueAllowUnset</code></p>
<p>See <a href="#using-valueallowunset-with-select-elements">Note 1</a> below. Note that <code>valueAllowUnset</code> is only applicable when using <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> to control selection on a <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> element. On other elements it has no effect.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="note-1-working-with-drop-down-lists-i-e-select-elements-">Note 1: Working with drop-down lists (i.e., <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> elements)</h3>
<p>Knockout has special support for drop-down lists (i.e., <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> elements). The <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> binding works in conjunction with the <code class="lang-apache"><span class="hljs-keyword"><span class="hljs-common">options</span></span></code> binding to let you read and write values that are arbitrary JavaScript objects, not just string values. This is very useful if you want to let the user select from a set of model objects. For examples of this, see <a href="options-binding.html">the <code class="lang-apache"><span class="hljs-keyword"><span class="hljs-common">options</span></span></code> binding</a> or for handling multi-select lists, see the documentation for <a href="selectedOptions-binding.html">the <code>selectedOptions</code> binding</a>.</p>
<p>You can also use the <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> binding with a <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> element that does not use the <code class="lang-apache"><span class="hljs-keyword"><span class="hljs-common">options</span></span></code> binding. In this case, you can choose to specify your <code class="lang-apache"><span class="hljs-tag">&lt;option&gt;</span></code> elements in markup or build them using the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> or <code class="lang-cpp"><span class="hljs-keyword">template</span></code> bindings. You can even nest options within <code class="lang-apache"><span class="hljs-tag">&lt;optgroup&gt;</span></code> elements and Knockout will set the selected value appropriately.</p>
<h4 id="using-valueallowunset-with-select-elements">Using <code>valueAllowUnset</code> with <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> elements</h4>
<p>Normally, when you use the <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> binding on a <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> element, it means that you want the associated model value to describe which item in the <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> is selected. But what happens if you set the model value to something that has no corresponding entry in the list? The default behavior is for Knockout to overwrite your model value to reset it to whatever is already selected in the dropdown, thereby preventing the model and UI from getting out of sync.</p>
<p>However, sometimes you might not want that behavior. If instead you want Knockout to allow your model observable to take values that have no corresponding entry in the <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code>, then specify <code class="lang-groovy"><span class="hljs-string">valueAllowUnset:</span> <span class="hljs-literal">true</span></code>. In this case, whenever your model value cannot be represented in the <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code>, then the <code class="lang-apache"><span class="hljs-tag">&lt;select&gt;</span></code> simply has no selected value at that time, which is visually represented by it being blank. When the user later selects an entry from the dropdown, this will be written to your model as usual. For example:</p>
<pre><code class="lang-html">  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>
      Select a country:
      <span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"options: countries,
                         optionsCaption: 'Choose one...',
                         value: selectedCountry,
                         valueAllowUnset: true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
</code></pre>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> viewModel = {
    countries: [<span class="hljs-string">'Japan'</span>, <span class="hljs-string">'Bolivia'</span>, <span class="hljs-string">'New Zealand'</span>],
    selectedCountry: ko.observable(<span class="hljs-string">'Latvia'</span>)
  };
</code></pre>
<p>In the above example, <code>selectedCountry</code> will retain the value <code class="lang-actionscript"><span class="hljs-string">'Latvia'</span></code>, and the dropdown will be blank, because there is no corresponding option.</p>
<p>If <code>valueAllowUnset</code> had not been enabled, then Knockout would have overwritten <code>selectedCountry</code> with <code class="lang-actionscript"><span class="hljs-literal">undefined</span></code>, so that it would match the value of the <code class="lang-actionscript"><span class="hljs-string">'Choose one...'</span></code> caption entry.</p>
<h3 id="note-2-updating-observable-and-non-observable-property-values">Note 2: Updating observable and non-observable property values</h3>
<p>If you use <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> to link a form element to an observable property, KO is able to set up a 2-way binding so that changes to either affect the other.</p>
<p>However, if you use <code class="lang-ceylon"><span class="hljs-keyword">value</span></code> to link a form element to a <em>non</em>-observable property (e.g., a plain old string, or an arbitrary JavaScript expression), KO will do the following:</p>
<ul>
<li><p>If you reference a <em>simple property</em>, i.e., it is just a regular property on your view model, KO will set the form element's initial state to the property value, and when the form element is edited, KO will write the changes back to your property. It cannot detect when the property changes (because it isn't observable), so this is only a 1-way binding.</p>
</li>
<li><p>If you reference something that is <em>not</em> a simple property, e.g., the result of a function call or comparison operation, KO will set the form element's initial state to that value, but it will not be able to write any changes back when the user edits the form element. In this case it's a one-time-only value setter, not an ongoing binding that reacts to changes.</p>
</li>
</ul>
<p>Example:</p>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- Two-way binding. Populates textbox; syncs both ways. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>First value: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"value: firstValue"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

<span class="hljs-comment">&lt;!-- One-way binding. Populates textbox; syncs only from textbox to model. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Second value: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"value: secondValue"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

<span class="hljs-comment">&lt;!-- No binding. Populates textbox, but doesn't react to any changes. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Third value: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"value: secondValue.length &gt; 8"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> viewModel = {
    firstValue: ko.observable(<span class="hljs-string">"hello"</span>), <span class="hljs-comment">// Observable</span>
    secondValue: <span class="hljs-string">"hello, again"</span>         <span class="hljs-comment">// Not observable</span>
};
</code></pre>
