<h3 id="purpose">Purpose</h3>
<p>The <code>options</code> binding controls what options should appear in a drop-down list (i.e., a <code>&lt;select&gt;</code> element) or multi-select list (e.g., <code>&lt;select size=&#39;6&#39;&gt;</code>). This binding cannot be used with anything other than <code>&lt;select&gt;</code> elements.</p>
<p>The value you assign should be an array (or observable array). The <code>&lt;select&gt;</code> element will then display one item for each item in your array.</p>
<p>Note: For a multi-select list, to set which of the options are selected, or to read which of the options are selected, use <a href="selectedOptions-binding.html">the <code>selectedOptions</code> binding</a>. For a single-select list, you can also read and write the selected option using <a href="value-binding.html">the <code>value</code> binding</a>.</p>
<h3 id="example-1-drop-down-list">Example 1: Drop-down list</h3>
<pre><code class="lang-html">&lt;p&gt;
    Destination country:
    &lt;select data-bind=&quot;options: availableCountries&quot;&gt;&lt;/select&gt;
&lt;/p&gt;
</code></pre>
<pre><code class="lang-javascript">var viewModel = {
    // These are the initial options
    availableCountries: ko.observableArray([&#39;France&#39;, &#39;Germany&#39;, &#39;Spain&#39;])
};

// ... then later ...
viewModel.availableCountries.push(&#39;China&#39;); // Adds another option
</code></pre>
<h3 id="example-2-multi-select-list">Example 2: Multi-select list</h3>
<pre><code class="lang-html">&lt;p&gt;
    Choose some countries you would like to visit:
    &lt;select data-bind=&quot;options: availableCountries&quot; size=&quot;5&quot; multiple=&quot;true&quot;&gt;&lt;/select&gt;
&lt;/p&gt;
</code></pre>
<pre><code class="lang-javascript">var viewModel = {
    availableCountries: ko.observableArray([&#39;France&#39;, &#39;Germany&#39;, &#39;Spain&#39;])
};
</code></pre>
<h3 id="example-3-drop-down-list-representing-arbitrary-javascript-objects-not-just-strings">Example 3: Drop-down list representing arbitrary JavaScript objects, not just strings</h3>
<pre><code class="lang-html">&lt;p&gt;
    Your country:
    &lt;select data-bind=&quot;options: availableCountries,
                       optionsText: &#39;countryName&#39;,
                       value: selectedCountry,
                       optionsCaption: &#39;Choose...&#39;&quot;&gt;&lt;/select&gt;
&lt;/p&gt;

&lt;div data-bind=&quot;visible: selectedCountry&quot;&gt; &lt;!-- Appears when you select something --&gt;
    You have chosen a country with population
    &lt;span data-bind=&quot;text: selectedCountry() ? selectedCountry().countryPopulation : &#39;unknown&#39;&quot;&gt;&lt;/span&gt;.
&lt;/div&gt;
</code></pre>
<pre><code class="lang-javascript">// Constructor for an object with two properties
var Country = function(name, population) {
    this.countryName = name;
    this.countryPopulation = population;
};

var viewModel = {
    availableCountries : ko.observableArray([
        new Country(&quot;UK&quot;, 65000000),
        new Country(&quot;USA&quot;, 320000000),
        new Country(&quot;Sweden&quot;, 29000000)
    ]),
    selectedCountry : ko.observable() // Nothing selected by default
};
</code></pre>
<h3 id="example-4-drop-down-list-representing-arbitrary-javascript-objects-with-displayed-text-computed-as-a-function-of-the-represented-item">Example 4: Drop-down list representing arbitrary JavaScript objects, with displayed text computed as a function of the represented item</h3>
<pre><code class="lang-html">&lt;!-- Same as example 3, except the &lt;select&gt; box expressed as follows: --&gt;
&lt;select data-bind=&quot;options: availableCountries,
                   optionsText: function(item) {
                       return item.countryName + &#39; (pop: &#39; + item.countryPopulation + &#39;)&#39;
                   },
                   value: selectedCountry,
                   optionsCaption: &#39;Choose...&#39;&quot;&gt;&lt;/select&gt;
</code></pre>
<p>Note that the only difference between examples 3 and 4 is the <code>optionsText</code> value.</p>
<h3 id="parameters">Parameters</h3>
<ul>
<li><p>Main parameter</p>
<p>You should supply an array (or observable array). For each item, KO will add an <code>&lt;option&gt;</code> to the associated <code>&lt;select&gt;</code> node. Any previous options will be removed.</p>
<p>If your parameter&#39;s value is an array of strings, you don&#39;t need to give any other parameters. The <code>&lt;select&gt;</code> element will display an option for each string value. However, if you want to let the user choose from an array of <em>arbitrary JavaScript objects</em> (not merely strings), then see the <code>optionsText</code> and <code>optionsValue</code> parameters below.</p>
<p>If this parameter is an observable value, the binding will update the element&#39;s available options whenever the value changes. If the parameter isn&#39;t observable, it will only set the element&#39;s available options once and will not update them again later.</p>
</li>
<li><p>Additional parameters</p>
<ul>
<li><p><code>optionsCaption</code></p>
<p>Sometimes, you might not want to select any particular option by default. But a single-select drop-down list usually starts with some item selected, so how can you avoid preselecting something? The usual solution is to prefix the list of options with a special dummy option that just reads &quot;Select an item&quot; or &quot;Please choose an option&quot; or similar, and have that one selected by default.</p>
<p>This easy to do: just add an additional parameter with name <code>optionsCaption</code>, with its value being a string to display. For example:</p>
<p><code>&lt;select data-bind=&#39;options: myOptions, optionsCaption: &quot;Select an item...&quot;, value: myChosenValue&#39;&gt;&lt;/select&gt;</code></p>
<p>KO will prefix the list of items with one that displays the text &quot;Select an item...&quot; and has the value <code>undefined</code>. So, if <code>myChosenValue</code> holds the value <code>undefined</code> (which observables do by default), then the dummy option will be selected. If the <code>optionsCaption</code> parameter is an observable, then the text of the initial item will update as the observable&#39;s value changes.</p>
</li>
<li><p><code>optionsText</code></p>
<p>See Example 3 above to see how you can bind <code>options</code> to an array of arbitrary JavaScript object - not just strings. In this case, you need to choose which of the objects&#39; properties should be displayed as the text in the drop-down list or multi-select list. Example 3 shows how you can specify that property name by passing an additional parameter called <code>optionsText</code>.</p>
<p>If you don&#39;t want to display just a simple property value as the text for each item in the dropdown, you can pass a JavaScript function for the <code>optionsText</code> option and supply your own arbitrary logic for computing the displayed text in terms of the represented object. See Example 4 above, which shows how you could generate the displayed text by concatenating together multiple property values.</p>
</li>
<li><p><code>optionsValue</code></p>
<p>Similar to <code>optionsText</code>, you can also pass an additional parameter called <code>optionsValue</code> to specify which of the objects&#39; properties should be used to set the <code>value</code> attribute on the <code>&lt;option&gt;</code> elements that KO generates. You can also specify a JavaScript function to determine this value. This function will receive the selected item as its only argument and should return a string to use for the <code>&lt;option&gt;</code> element&#39;s value attribute.</p>
<p>Typically you&#39;d only want to use <code>optionsValue</code> as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you&#39;re repeatedly getting a list of &quot;car&quot; objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set <code>optionsValue</code> to <code>&quot;carId&quot;</code> or whatever unique identifier each &quot;car&quot; object has, otherwise KO won&#39;t necessarily know which of the previous &quot;car&quot; objects corresponds to which of the new ones.</p>
</li>
<li><p><code>optionsIncludeDestroyed</code></p>
<p>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a non-destructive delete. For details of how to do this, see <a href="observableArrays.html#destroy_and_destroyall_note_usually_relevant_to_ruby_on_rails_developers_only">the destroy function on <code>observableArray</code></a>.</p>
<p>By default, the options binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, then specify this additional parameter like:</p>
<p><code>&lt;select data-bind=&#39;options: myOptions, optionsIncludeDestroyed: true&#39;&gt;&lt;/select&gt;</code></p>
</li>
<li><p><code>optionsAfterRender</code></p>
<p>If you need to run some further custom logic on the generated <code>option</code> elements, you can use the <code>optionsAfterRender</code> callback. See Note 2 below.</p>
</li>
<li><p><code>selectedOptions</code></p>
<p>For a multi-select list, you can read and write the selection state using <code>selectedOptions</code>. Technically this is a separate binding, so it has <a href="selectedOptions-binding.html">its own documentation</a>.</p>
</li>
<li><p><code>valueAllowUnset</code></p>
<p>If you want Knockout to allow your model property to take values that have no corresponding entry in your <code>&lt;select&gt;</code> element (and display this by making the <code>&lt;select&gt;</code> element blank), then see <a href="value-binding.html#using-valueallowunset-with-select-elements">documentation for <code>valueAllowUnset</code></a>.</p>
</li>
</ul>
</li>
</ul>
<h3 id="note-1-selection-is-preserved-when-setting-changing-options">Note 1: Selection is preserved when setting/changing options</h3>
<p>When the <code>options</code> binding changes the set of options in your <code>&lt;select&gt;</code> element, KO will leave the user&#39;s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you&#39;ve removed one or more of those options).</p>
<p>That&#39;s because the <code>options</code> binding tries to be independent of the <code>value</code> binding (which controls selection for a single-select list) and the <code>selectedOptions</code> binding (which controls selection for a multi-select list).</p>
<h3 id="note-2-post-processing-the-generated-options">Note 2: Post-processing the generated options</h3>
<p>If you need to run some further custom logic on the generated <code>option</code> elements, you can use the <code>optionsAfterRender</code> callback. The callback function is invoked each time an <code>option</code> element is inserted into the list, with the following parameters:</p>
<ol>
<li>The inserted <code>option</code> element</li>
<li>The data item against which it is bound, or <code>undefined</code> for the caption element</li>
</ol>
<p>Here&#39;s an example that uses <code>optionsAfterRender</code> to add a <code>disable</code> binding to each option.</p>
<pre><code class="lang-html">&lt;select size=3 data-bind=&quot;
    options: myItems,
    optionsText: &#39;name&#39;,
    optionsValue: &#39;id&#39;,
    optionsAfterRender: setOptionDisable&quot;&gt;
&lt;/select&gt;
</code></pre>
<pre><code class="lang-javascript">var vm = {
    myItems: [
        { name: &#39;Item 1&#39;, id: 1, disable: ko.observable(false)},
        { name: &#39;Item 3&#39;, id: 3, disable: ko.observable(true)},
        { name: &#39;Item 4&#39;, id: 4, disable: ko.observable(false)}
    ],
    setOptionDisable: function(option, item) {
        ko.applyBindingsToNode(option, {disable: item.disable}, item);
    }
};
ko.applyBindings(vm);
</code></pre>
<h3 id="dependencies">Dependencies</h3>
<p>None, other than the core Knockout library.</p>
