<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>foreach</title>
  <meta name="description" content="It&#x27;s about saying »Hello« to the world.">
	<link rel="stylesheet" href="/assets/css/code.css">
</head>
<body>
  <header>
    <p>
      <a href="/">Home</a>
    </p>
  </header>
  <h1>foreach</h1>

  <h3 id="purpose">Purpose</h3>
<p>The <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.</p>
<p>Assuming your array is an <a href="observableArrays.html">observable array</a>, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match - inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements. This is far faster than regenerating the entire <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> output after each array change.</p>
<p>Of course, you can arbitrarily nest any number of <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> bindings along with other control-flow bindings such as <code class="lang-actionscript"><span class="hljs-keyword">if</span></code> and <code class="lang-actionscript"><span class="hljs-keyword">with</span></code>.</p>
<h3 id="example-1-iterating-over-an-array">Example 1: Iterating over an array</h3>
<p>This example uses <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> to produce a read-only table with a row for each array entry.</p>
<p><live-example params="id: &quot;foreach&quot;"></live-example></p>
<p><em>Note: Table headers might disappear if the screen is small.</em></p>
<h3 id="example-2-live-example-with-add-remove">Example 2: Live example with add/remove</h3>
<p>The following example shows that, if your array is observable, then the UI will be kept in sync with changes to that array.</p>
<p><live-example params="id: &quot;foreach-people&quot;"></live-example></p>
<h3 id="parameters">Parameters</h3>
<ul>
<li><p>Main parameter</p>
<p>Pass the array that you wish to iterate over. The binding will output a section of markup for each entry.</p>
<p>Alternatively, pass a JavaScript object literal with a property called <code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span></span></code> which is the array you wish to iterate over. The object
literal may also have other properties, such as <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Add</span></code> or <code>includeDestroyed</code> --- see below for details of these extra options and
examples of their use.</p>
<p>If the array you supply is observable, the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding will respond to any future changes in the array's contents by adding or
removing corresponding sections of markup in the DOM.</p>
</li>
<li><p>Additional parameters</p>
<ul>
<li>None</li>
</ul>
</li>
</ul>
<h3 id="note-1-referring-to-each-array-entry-using-data">Note 1: Referring to each array entry using $data</h3>
<p>As shown in the above examples, bindings within the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> block can refer to properties on the array entries. For example, <a href="#example_1_iterating_over_an_array">Example 1</a> referenced the <code>firstName</code> and <code>lastName</code> properties on each array entry.</p>
<p>But what if you want to refer to the array entry itself (not just one of its properties)? In that case, you can use the <a href="binding-context.html">special context property</a> <code class="lang-xquery"><span class="hljs-variable">$data</span></code>. Within a <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> block, it means "the current item". For example,</p>
<p><live-example params="id: &quot;foreach-$data&quot;"></live-example></p>
<p>If you wanted, you could use <code class="lang-xquery"><span class="hljs-variable">$data</span></code> as a prefix when referencing properties on each entry. For example, you could rewrite part of <a href="#example_1_iterating_over_an_array">Example 1</a> as follows:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">td</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: $data.firstName"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">td</span>&gt;</span>
</code></pre>
<p>... but you don't have to, because <code>firstName</code> will be evaluated within the context of <code class="lang-xquery"><span class="hljs-variable">$data</span></code> by default anyway.</p>
<h3 id="note-2-using-index-parent-and-other-context-properties">Note 2: Using $index, $parent, and other context properties</h3>
<p>As you can see from Example 2 above, it's possible to use <code class="lang-xquery"><span class="hljs-variable">$index</span></code> to refer to the zero-based index of the current array item. <code class="lang-xquery"><span class="hljs-variable">$index</span></code> is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</p>
<p>Similarly, you can use <code class="lang-xquery"><span class="hljs-variable">$parent</span></code> to refer to data from outside the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code>, e.g.:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">h1</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: blogPostTitle"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"foreach: likes"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">b</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">b</span>&gt;</span> likes the blog
        post <span class="hljs-tag">&lt;<span class="hljs-title">b</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: $parent.blogPostTitle"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">b</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p>For more information about <code class="lang-xquery"><span class="hljs-variable">$index</span></code> and other context properties such as <code class="lang-xquery"><span class="hljs-variable">$parent</span></code>, see documentation for <a href="binding-context.html">binding context properties</a>.</p>
<h3 id="note-3-using-as-to-give-an-alias-to-foreach-items">Note 3: Using "as" to give an alias to "foreach" items</h3>
<p>As described in Note 1, you can refer to each array entry using the <code class="lang-xquery"><span class="hljs-variable">$data</span></code> <a href="binding-context.html">context variable</a>. In some cases though, it may be useful to give the current item a more descriptive name using the <code class="lang-actionscript"><span class="hljs-keyword">as</span></code> option like:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"foreach: { data: people, as: 'person' }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p>Now anywhere inside this <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> loop, bindings will be able to refer to <code class="lang-inform7"><span class="hljs-keyword">person</span></code> to access the current array item, from the <code>people</code> array, that is being rendered. This can be especially useful in scenarios where you have nested <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</p>
<p><live-example params="id: &quot;foreach-cats&quot;"></live-example></p>
<p>Tip: Remember to pass a <em>string literal value</em> to <code class="lang-actionscript"><span class="hljs-keyword">as</span></code> (e.g., <code class="lang-actionscript"><span class="hljs-keyword">as</span>: <span class="hljs-string">'category'</span></code>, <em>not</em> <code class="lang-http"><span class="hljs-attribute">as</span>: <span class="hljs-string">category</span></code>), because you are giving a name for a new variable, not reading the value of a variable that already exists.</p>
<h3 id="note-4-using-foreach-without-a-container-element">Note 4: Using foreach without a container element</h3>
<p>In some cases, you might want to duplicate a section of markup, but you don't have any container element on which to put a <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding. For example, you might want to generate the following:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"header"</span>&gt;</span>Header item<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- The following are generated dynamically from an array --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>Item A<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>Item B<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>Item C<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p>In this example, there isn't anywhere to put a normal <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding. You can't put it on the <code class="lang-apache"><span class="hljs-tag">&lt;ul&gt;</span></code> (because then you'd be duplicating the header item), nor can you put a further container inside the <code class="lang-apache"><span class="hljs-tag">&lt;ul&gt;</span></code> (because only <code class="lang-apache"><span class="hljs-tag">&lt;li&gt;</span></code> elements are allowed inside <code class="lang-apache"><span class="hljs-tag">&lt;ul&gt;</span></code>s).</p>
<p>To handle this, you can use the <em>containerless control flow syntax</em>, which is based on comment tags. For example,</p>
<p><live-example params="id: &quot;foreach-virtual&quot;"></live-example></p>
<p>The <code class="lang-xml"><span class="hljs-comment">&lt;!-- ko --&gt;</span></code> and <code class="lang-xml"><span class="hljs-comment">&lt;!-- /ko --&gt;</span></code> comments act as start/end markers, defining a "virtual element" that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</p>
<h3 id="note-5-how-array-changes-are-detected-and-handled">Note 5: How array changes are detected and handled</h3>
<p>When you modify the contents of your model array (by adding, moving, or deleting its entries), the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.</p>
<ul>
<li>When you <strong>add</strong> array entries, <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> will render new copies of your template and insert them into the existing DOM</li>
<li>When you <strong>delete</strong> array entries, <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> will simply remove the corresponding DOM elements</li>
<li>When you <strong>reorder</strong> array entries (retaining the same object instances), <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> will typically just move the corresponding DOM elements into their new position</li>
</ul>
<p>Note that reordering detection is not guaranteed: to ensure the algorithm completes quickly, it is optimized to detect "simple" movements of small numbers of array entries. If the algorithm detects too many simultaneous reorderings combined with unrelated insertions and deletions, then for speed it can choose to regard a reordering as an "delete" plus an "add" instead of a single "move", and in that case the corresponding DOM elements will be torn down and recreated. Most developers won't encounter this edge case, and even if you do, the end-user experience will usually be identical.</p>
<h3 id="note-6-destroyed-entries-are-hidden-by-default">Note 6: Destroyed entries are hidden by default</h3>
<p>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a <em>non-destructive delete</em>. For details of how to do this, see <a href="observableArrays.html#destroy_and_destroyall_note_usually_relevant_to_ruby_on_rails_developers_only">the destroy function on <code>observableArray</code></a>.</p>
<p>By default, the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the <code>includeDestroyed</code> option. For example,</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">'foreach: { data: myArray, includeDestroyed: true }'</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<h3 id="note-7-post-processing-or-animating-the-generated-dom-elements">Note 7: Post-processing or animating the generated DOM elements</h3>
<p>If you need to run some further custom logic on the generated DOM elements, you can use any of the <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Render</span></code>/<code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Add</span></code>/<code>beforeRemove</code>/<code>beforeMove</code>/<code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Move</span></code> callbacks described below.</p>
<blockquote>
<p><strong>Note:</strong> These callbacks are <em>only</em> intended for triggering animations related to changes in a list. If your goal is actually to attach other behaviors to new DOM elements when they have been added (e.g., event handlers, or to activate third-party UI controls), then your work will be much easier if you implement that new behavior as a <a href="custom-bindings.html">custom binding</a> instead, because then you can use that behavior anywhere, independently of the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding.</p>
</blockquote>
<p>Here's a trivial example that uses <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Add</span></code> to apply the classic "yellow fade" effect to newly-added items. It requires the <a href="https://github.com/jquery/jquery-color">jQuery Color plugin</a> to enable animation of background colors.</p>
<p><live-example params="id: &quot;foreach-afteradd&quot;"></live-example></p>
<p>Full details:</p>
<ul>
<li><p><code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Render</span></code> --- is invoked each time the <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> block is duplicated and inserted into the document, both when <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:</p>
<ol>
<li>An array of the inserted DOM elements</li>
<li>The data item against which they are being bound</li>
</ol>
</li>
<li><p><code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Add</span></code> --- is like <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Render</span></code>, except it is invoked only when new entries are added to your array (and <em>not</em> when <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> first iterates over your array's initial contents). A common use for <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Add</span></code> is to call a method such as jQuery's <code class="lang-stylus">$(domNode).<span class="hljs-function"><span class="hljs-title">fadeIn</span><span class="hljs-params">()</span></span></code> so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:</p>
<ol>
<li>A DOM node being added to the document</li>
<li>The index of the added array element</li>
<li>The added array element</li>
</ol>
</li>
<li><p><code>beforeRemove</code> --- is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a <code>beforeRemove</code> callback, then <em>it becomes your responsibility to remove the DOM nodes</em>. The obvious use case here is calling something like jQuery's <code class="lang-stylus">$(domNode).<span class="hljs-function"><span class="hljs-title">fadeOut</span><span class="hljs-params">()</span></span></code> to animate the removal of the corresponding DOM nodes --- in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:</p>
<ol>
<li>A DOM node that you should remove</li>
<li>The index of the removed array element</li>
<li>The removed array element</li>
</ol>
</li>
<li><p><code>beforeMove</code> --- is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that <code>beforeMove</code> applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use <code>beforeMove</code> to store the original screen coordinates of the affected elements so that you can animate their movements in the <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Move</span></code> callback.  Knockout will supply the following parameters to your callback:</p>
<ol>
<li>A DOM node that may be about to move</li>
<li>The index of the moved array element</li>
<li>The moved array element</li>
</ol>
</li>
<li><p><code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Move</span></code> --- is invoked after an array item has changed position in the array, and after <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> has updated the DOM to match. Note that <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Move</span></code> applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:</p>
<ol>
<li>A DOM node that may have moved</li>
<li>The index of the moved array element</li>
<li>The moved array element</li>
</ol>
</li>
</ul>
<p>For examples of <code class="lang-erlang"><span class="hljs-keyword">after</span><span class="hljs-variable">Add</span></code> and <code>beforeRemove</code> see <a href="#animated">animated transitions</a>.</p>


  <footer>
    <p>Generated with Metalsmith &mdash; <a href="http://metalsmith.io">http://metalsmith.io</a></p>
  </footer>

</body>
</html>
