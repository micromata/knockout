<p>The following documentation describes how to construct and work with computed observables.</p>
<h2 id="constructing-a-computed-observable">Constructing a computed observable</h2>
<p>A computed observable can be constructed using one of the following forms:</p>
<ol>
<li><p><code class="lang-stylus">ko.<span class="hljs-function"><span class="hljs-title">computed</span><span class="hljs-params">( evaluator [, targetObject, options] )</span></span></code> --- This form supports the most common case of creating a computed observable.</p>
<ul>
<li><code>evaluator</code> --- A function that is used to evaluate the computed observable's current value.</li>
<li><code>targetObject</code> --- If given, defines the value of <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> whenever KO invokes your callback functions. See the section on <a href="computedObservables.html#managing-this">managing <code class="lang-actionscript"><span class="hljs-keyword">this</span></code></a> for more information.</li>
<li><code class="lang-apache"><span class="hljs-keyword"><span class="hljs-common">options</span></span></code> --- An object with further properties for the computed observable. See the full list below.</li>
</ul>
</li>
<li><p><code class="lang-stylus">ko.<span class="hljs-function"><span class="hljs-title">computed</span><span class="hljs-params">( options )</span></span></code> --- This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</p>
<ul>
<li><code class="lang-applescript"><span class="hljs-command">read</span></code> --- Required. A function that is used to evaluate the computed observable's current value.</li>
<li><code class="lang-applescript"><span class="hljs-command">write</span></code> --- Optional. If given, makes the computed observable writable. This is a function that receives values that other code is trying to write to your computed observable. It's up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</li>
<li><code class="lang-sqf"><span class="hljs-built_in">owner</span></code> --- Optional. If given, defines the value of <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> whenever KO invokes your <code class="lang-applescript"><span class="hljs-command">read</span></code> or <code class="lang-applescript"><span class="hljs-command">write</span></code> callbacks.</li>
<li><code class="lang-d"><span class="hljs-keyword">pure</span></code> --- Optional. If this option is <code class="lang-actionscript"><span class="hljs-literal">true</span></code>, the computed observable will be set up as a <a href="computed-pure.html"><em>pure</em> computed observable</a>. This option is an alternative to the <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.pureComputed</span></code> constructor.</li>
<li><code>deferEvaluation</code> --- Optional. If this option is <code class="lang-actionscript"><span class="hljs-literal">true</span></code>, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</li>
<li><code>disposeWhen</code> --- Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A <code class="lang-actionscript"><span class="hljs-literal">true</span></code>-ish result will trigger disposal of the computed observable.</li>
<li><code>disposeWhenNodeIsRemoved</code> --- Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the <code class="lang-cpp"><span class="hljs-keyword">template</span></code> and control-flow bindings.</li>
</ul>
</li>
<li><p><code class="lang-stylus">ko.<span class="hljs-function"><span class="hljs-title">pureComputed</span><span class="hljs-params">( evaluator [, targetObject] )</span></span></code> --- Constructs a <a href="computed-pure.html"><em>pure</em> computed observable</a> using the given evaluator function and optional object to use for <code class="lang-actionscript"><span class="hljs-keyword">this</span></code>. Unlike <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computed</span></code>, this method doesn't accept an <code class="lang-apache"><span class="hljs-keyword"><span class="hljs-common">options</span></span></code> parameter.</p>
</li>
<li><p><code class="lang-stylus">ko.<span class="hljs-function"><span class="hljs-title">pureComputed</span><span class="hljs-params">( options )</span></span></code> --- Constructs a <em>pure</em> computed observable using an <code class="lang-apache"><span class="hljs-keyword"><span class="hljs-common">options</span></span></code> object. This accepts the <code class="lang-applescript"><span class="hljs-command">read</span></code>, <code class="lang-applescript"><span class="hljs-command">write</span></code>, and <code class="lang-sqf"><span class="hljs-built_in">owner</span></code> options described above.</p>
</li>
</ol>
<h2 id="using-a-computed-observable">Using a computed observable</h2>
<p>A computed observable provides the following functions:</p>
<ul>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">dispose</span><span class="hljs-params">()</span></span></code> --- Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won't be cleaned.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">extend</span><span class="hljs-params">(extenders)</span></span></code> --- Applies the given <a href="extenders.html">extenders</a> to the computed observable.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">getDependenciesCount</span><span class="hljs-params">()</span></span></code> --- Returns the current number of dependencies of the computed observable.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">getSubscriptionsCount</span><span class="hljs-params">( [event] )</span></span></code> --- Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like <code class="lang-1c"><span class="hljs-string">"change"</span></code>) to return just the count of subscriptions for that event.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">isActive</span><span class="hljs-params">()</span></span></code> --- Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">peek</span><span class="hljs-params">()</span></span></code> --- Returns the current value of the computed observable without creating a dependency (see the section on <a href="computed-dependency-tracking.html#controlling-dependencies-using-peek"><code>peek</code></a>).</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">subscribe</span><span class="hljs-params">( callback [,callbackTarget, event] )</span></span></code> --- Registers a <a href="observables.html#explicitly-subscribing-to-observables">manual subscription</a> to be notified of changes to the computed observable.</li>
</ul>
<h2 id="using-the-computed-context">Using the computed context</h2>
<p>During the execution of a computed observable's evaluator function, you can access <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computedContext</span></code> to get information about the current computed property. It provides the following functions:</p>
<ul>
<li><p><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">isInitial</span><span class="hljs-params">()</span></span></code> --- A function that returns <code class="lang-actionscript"><span class="hljs-literal">true</span></code> if called during the first ever evaluation of the current computed observable, or <code class="lang-actionscript"><span class="hljs-literal">false</span></code> otherwise. For <em>pure</em> computed observables, <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">isInitial</span><span class="hljs-params">()</span></span></code> is always <code class="lang-actionscript"><span class="hljs-literal">undefined</span></code>.</p>
</li>
<li><p><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">getDependenciesCount</span><span class="hljs-params">()</span></span></code> --- Returns the number of dependencies of the computed observable detected so far during the current evaluation.</p>
<ul>
<li>Note: <code class="lang-stylus">ko<span class="hljs-class">.computedContext</span><span class="hljs-class">.getDependenciesCount</span>()</code> is equivalent to calling <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">getDependenciesCount</span><span class="hljs-params">()</span></span></code> on the computed observable itself. The reason that it also exists on <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computedContext</span></code> is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myComputed = ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ... Omitted: read some data that might be observable ...</span>

    <span class="hljs-comment">// Now let's inspect ko.computedContext</span>
    <span class="hljs-keyword">var</span> isFirstEvaluation = ko.computedContext.isInitial(),
        dependencyCount = ko.computedContext.getDependenciesCount(),
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Evaluating "</span> + (isFirstEvaluation ? <span class="hljs-string">"for the first time"</span> : <span class="hljs-string">"again"</span>));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"By now, this computed has "</span> + dependencyCount + <span class="hljs-string">" dependencies"</span>);

    <span class="hljs-comment">// ... Omitted: return the result ...</span>
});
</code></pre>
<p>These facilities are typically useful only in advanced scenarios, for example when your computed observable's primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</p>
