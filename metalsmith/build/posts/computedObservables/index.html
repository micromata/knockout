<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Computed Observables</title>
  <meta name="description" content="It&#x27;s about saying »Hello« to the world.">
	<link rel="stylesheet" href="/assets/css/code.css">
</head>
<body>
  <header>
    <p>
      <a href="/">Home</a>
    </p>
  </header>
  <h1>Computed Observables</h1>

  <p>What if you've got an <a href="observables.html">observable</a> for <code>firstName</code>, and another for <code>lastName</code>, and you want to display the full name? That's where <em>computed observables</em> come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</p>
<p>For example, given the following view model class,</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AppViewModel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.firstName = ko.observable(<span class="hljs-string">'Bob'</span>);
    <span class="hljs-keyword">this</span>.lastName = ko.observable(<span class="hljs-string">'Smith'</span>);
}
</code></pre>
<p>... you could add a computed observable to return the full name:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AppViewModel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ... leave firstName and lastName unchanged ...</span>

    <span class="hljs-keyword">this</span>.fullName = ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName() + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.lastName();
    }, <span class="hljs-keyword">this</span>);
}
</code></pre>
<p>Now you could bind UI elements to it, e.g.:</p>
<pre><code class="lang-html">The name is <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: fullName"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
</code></pre>
<p>... and they will be updated whenever <code>firstName</code> or <code>lastName</code> changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</p>
<h3 id="managing-this-">Managing 'this'</h3>
<p><em>Beginners may wish to skip this section - as long as you follow the same coding patterns as the examples, you won't need to know or care about it!</em></p>
<p>In case you're wondering what the second parameter to <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computed</span></code> is (the bit where we passed <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> in the preceding code), that defines the value of <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> when evaluating the computed observable. Without passing it in, it would not have been possible to refer to <code class="lang-stylus">this.<span class="hljs-function"><span class="hljs-title">firstName</span><span class="hljs-params">()</span></span></code> or <code class="lang-stylus">this.<span class="hljs-function"><span class="hljs-title">lastName</span><span class="hljs-params">()</span></span></code>. Experienced JavaScript coders will regard this as obvious, but if you're still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for <code class="lang-actionscript"><span class="hljs-keyword">this</span></code>, but JavaScript does, because its functions themselves aren't part of any object by default.)</p>
<h4 id="a-popular-convention-that-simplifies-things">A popular convention that simplifies things</h4>
<p>There's a popular convention for avoiding the need to track <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> altogether: if your viewmodel's constructor copies a reference to <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> into a different variable (traditionally called <code class="lang-crystal"><span class="hljs-keyword">self</span></code>), you can then use <code class="lang-crystal"><span class="hljs-keyword">self</span></code> throughout your viewmodel and don't have to worry about it being redefined to refer to something else. For example:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AppViewModel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    self.firstName = ko.observable(<span class="hljs-string">'Bob'</span>);
    self.lastName = ko.observable(<span class="hljs-string">'Smith'</span>);
    self.fullName = ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> self.firstName() + <span class="hljs-string">" "</span> + self.lastName();
    });
}
</code></pre>
<p>Because <code class="lang-crystal"><span class="hljs-keyword">self</span></code> is captured in the function's closure, it remains available and consistent in any nested functions, such as the <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computed</span></code> evaluator. This convention is even more useful when it comes to event handlers, as you'll see in many of the <a href="../examples/">live examples</a>.</p>
<h3 id="dependency-chains-just-work">Dependency chains just work</h3>
<p>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</p>
<ul>
<li>an <strong>observable</strong> called <code class="lang-livecodeserver"><span class="hljs-keyword">items</span></code> representing a set of items</li>
<li>another <strong>observable</strong> called <code>selectedIndexes</code> storing which item indexes have been 'selected' by the user</li>
<li>a <strong>computed observable</strong> called <code>selectedItems</code> that returns an array of item objects corresponding to the selected indexes</li>
<li>another <strong>computed observable</strong> that returns <code class="lang-actionscript"><span class="hljs-literal">true</span></code> or <code class="lang-actionscript"><span class="hljs-literal">false</span></code> depending on whether any of <code>selectedItems</code> has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</li>
</ul>
<p>Then, changes to <code class="lang-livecodeserver"><span class="hljs-keyword">items</span></code> or <code>selectedIndexes</code> will ripple through the chain of computed observables, which in turn updates any UI bound to them. Very tidy and elegant.</p>
<h3 id="forcing-computed-observables-to-always-notify-subscribers">Forcing computed observables to always notify subscribers</h3>
<p>When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in <code class="lang-oxygene"><span class="hljs-keyword">notify</span></code> <a href="extenders.html">extender</a> to ensure that a computed observable's subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:</p>
<pre><code class="lang-javascript">myViewModel.fullName = ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> myViewModel.firstName() + <span class="hljs-string">" "</span> + myViewModel.lastName();
}).extend({ notify: <span class="hljs-string">'always'</span> });
</code></pre>
<h3 id="delaying-and-or-suppressing-change-notifications">Delaying and/or suppressing change notifications</h3>
<p>Normally, a computed observable updates and notifies its subscribers immediately, as soon as its dependencies change. But if a computed observable has many dependencies or involves expensive updates, you may get better performance by limiting or delaying the computed observable's updates and notifications. This is accomplished using the <a href="rateLimit-observable.html"><code>rateLimit</code> extender</a> like this:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Ensure updates no more than once per 50-millisecond period</span>
myViewModel.fullName.extend({ rateLimit: <span class="hljs-number">50</span> });
</code></pre>
<h1 id="writeable-computed-observables">Writeable computed observables</h1>
<p><em>Beginners may wish to skip this section - writeable computed observables are fairly advanced and are not necessary in most situations</em></p>
<p>As you've learned, computed observables have a value that is computed from other observables. In that sense, computed observables are normally <em>read-only</em>. What may seem surprising, then, is that it is possible to make computed observables <em>writeable</em>. You just need to supply your own callback function that does something sensible with written values.</p>
<p>You can then use your writeable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. This is a powerful feature with a wide range of possible uses. Just like observables, you can write values to multiple observable or computed observable properties on a model object using <em>chaining syntax</em>. For example, <code class="lang-stylus">myViewModel.<span class="hljs-function"><span class="hljs-title">fullName</span><span class="hljs-params">(<span class="hljs-string">'Joe Smith'</span>)</span></span>.<span class="hljs-function"><span class="hljs-title">age</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span></code>.</p>
<h3 id="example-1-decomposing-user-input">Example 1: Decomposing user input</h3>
<p>Going back to the classic "first name + last name = full name" example, you can turn things back-to-front: make the <code>fullName</code> computed observable writeable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying <code>firstName</code> and <code>lastName</code> observables:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyViewModel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.firstName = ko.observable(<span class="hljs-string">'Planet'</span>);
    <span class="hljs-keyword">this</span>.lastName = ko.observable(<span class="hljs-string">'Earth'</span>);

    <span class="hljs-keyword">this</span>.fullName = ko.computed({
        read: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName() + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.lastName();
        },
        write: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">var</span> lastSpacePos = value.lastIndexOf(<span class="hljs-string">" "</span>);
            <span class="hljs-keyword">if</span> (lastSpacePos &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// Ignore values with no space character</span>
                <span class="hljs-keyword">this</span>.firstName(value.substring(<span class="hljs-number">0</span>, lastSpacePos)); <span class="hljs-comment">// Update "firstName"</span>
                <span class="hljs-keyword">this</span>.lastName(value.substring(lastSpacePos + <span class="hljs-number">1</span>)); <span class="hljs-comment">// Update "lastName"</span>
            }
        },
        owner: <span class="hljs-keyword">this</span>
    });
}

ko.applyBindings(<span class="hljs-keyword">new</span> MyViewModel());
</code></pre>
<p>In this example, the <code class="lang-applescript"><span class="hljs-command">write</span></code> callback handles incoming values by splitting the incoming text into "firstName" and "lastName" components, and writing those values back to the underlying observables. You can bind this view model to your DOM in the obvious way, as follows:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>First name: <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: firstName"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Last name: <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: lastName"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>Hello, <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"value: fullName"</span>/&gt;</span>!<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
</code></pre>
<p>This is the exact opposite of the <a href="../examples/helloWorld.html">Hello World</a> example, in that here the first and last names are not editable, but the combined full name is editable.</p>
<p>The preceding view model code demonstrates the <em>single parameter syntax</em> for initializing computed observables. See the <a href="#computed_observable_reference">computed observable reference</a> below for the full list of available options.</p>
<h3 id="example-2-a-value-converter">Example 2: A value converter</h3>
<p>Sometimes you might want to represent a data point on the screen in a different format from its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writeable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyViewModel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.price = ko.observable(<span class="hljs-number">25.99</span>);

    <span class="hljs-keyword">this</span>.formattedPrice = ko.computed({
        read: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">'$'</span> + <span class="hljs-keyword">this</span>.price().toFixed(<span class="hljs-number">2</span>);
        },
        write: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            <span class="hljs-comment">// Strip out unwanted characters, parse as float, then write the raw data back to the underlying "price" observable</span>
            value = <span class="hljs-built_in">parseFloat</span>(value.replace(<span class="hljs-regexp">/[^\.\d]/g</span>, <span class="hljs-string">""</span>));
            <span class="hljs-keyword">this</span>.price(<span class="hljs-built_in">isNaN</span>(value) ? <span class="hljs-number">0</span> : value); <span class="hljs-comment">// Write to underlying storage</span>
        },
        owner: <span class="hljs-keyword">this</span>
    });
}

ko.applyBindings(<span class="hljs-keyword">new</span> MyViewModel());
</code></pre>
<p>It's trivial to bind the formatted price to a text box:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Enter bid price: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"value: formattedPrice"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
</code></pre>
<p>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can't enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can't enter negative values, because the <code class="lang-applescript"><span class="hljs-command">write</span></code> callback strips off any minus sign.</p>
<h3 id="example-3-filtering-and-validating-user-input">Example 3: Filtering and validating user input</h3>
<p>Example 1 showed how a writeable computed observable can effectively <em>filter</em> its incoming data by choosing not to write certain values back to the underlying observables if they don't meet some criteria. It ignored full name values that didn't include a space.</p>
<p>Taking this a step further, you could also toggle an <code>isValid</code> flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. There's an easier way of doing validation (explained below), but first consider the following view model, which demonstrates the mechanism:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyViewModel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.acceptedNumericValue = ko.observable(<span class="hljs-number">123</span>);
    <span class="hljs-keyword">this</span>.lastInputWasValid = ko.observable(<span class="hljs-literal">true</span>);

    <span class="hljs-keyword">this</span>.attemptedValue = ko.computed({
        read: <span class="hljs-keyword">this</span>.acceptedNumericValue,
        write: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(value))
                <span class="hljs-keyword">this</span>.lastInputWasValid(<span class="hljs-literal">false</span>);
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.lastInputWasValid(<span class="hljs-literal">true</span>);
                <span class="hljs-keyword">this</span>.acceptedNumericValue(value); <span class="hljs-comment">// Write to underlying storage</span>
            }
        },
        owner: <span class="hljs-keyword">this</span>
    });
}

ko.applyBindings(<span class="hljs-keyword">new</span> MyViewModel());
</code></pre>
<p>... with the following DOM elements:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Enter a numeric value: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"value: attemptedValue"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"visible: !lastInputWasValid()"</span>&gt;</span>That's not a number!<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>Now, <code>acceptedNumericValue</code> will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating <code>acceptedNumericValue</code>.</p>
<p><strong>Note:</strong> For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its <code class="lang-applescript"><span class="hljs-type">number</span></code> class on the <code class="lang-apache"><span class="hljs-tag">&lt;input&gt;</span></code> element. Knockout and jQuery Validation work together nicely, as demonstrated on the <a href="../examples/gridEditor.html">grid editor</a> example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</p>
<h1 id="how-dependency-tracking-works">How dependency tracking works</h1>
<p><em>Beginners don't need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI...</em></p>
<p>It's actually very simple and rather lovely. The tracking algorithm goes like this:</p>
<ol>
<li>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</li>
<li>While your evaluator function is running, KO keeps a log of any observables (or computed observables) that your evaluator reads the value of.</li>
<li>When your evaluator is finished, KO sets up subscriptions to each of the observables (or computed observables) that you've touched. The subscription callback is set to cause your evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</li>
<li>KO notifies any subscribers about the new value of your computed observable.</li>
</ol>
<p>So, KO doesn't just detect your dependencies the first time your evaluator runs - it redetects them every time. This means, for example, that your dependencies can vary dynamically: dependency A could determine whether you also depend on B or C. Then, you'll only be re-evaluated when either A or your current choice of B or C changes.  You don't have to declare dependencies: they're inferred at runtime from the code's execution.</p>
<p>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</p>
<h3 id="controlling-dependencies-using-peek">Controlling dependencies using peek</h3>
<p>Knockout's automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The <code>peek</code> function lets you access an observable or computed observable without creating a dependency.</p>
<p>In the example below, a computed observable is used to reload an observable named <code>currentPageData</code> using Ajax with data from two other observable properties. The computed observable will update whenever <code>pageIndex</code> changes, but it ignores changes to <code>selectedItem</code> because it is accessed using <code>peek</code>. In this case, the user might want to use the current value of <code>selectedItem</code> only for tracking purposes when a new set of data is loaded.</p>
<pre><code class="lang-javascript">ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> params = {
        page: <span class="hljs-keyword">this</span>.pageIndex(),
        selected: <span class="hljs-keyword">this</span>.selectedItem.peek()
    };
    $.getJSON(<span class="hljs-string">'/Some/Json/Service'</span>, params, <span class="hljs-keyword">this</span>.currentPageData);
}, <span class="hljs-keyword">this</span>);
</code></pre>
<p>Note: If you just want to prevent a computed observable from updating too often, see the <a href="rateLimit-observable.html"><code>rateLimit</code> extender</a>.</p>
<h3 id="note-why-circular-dependencies-aren-t-meaningful">Note: Why circular dependencies aren't meaningful</h3>
<p>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn't make sense to include cycles in your dependency chains. Cycles would <em>not</em> be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</p>
<p>So what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: <strong>Knockout will not restart evaluation of a computed while it is already evaluating</strong>. This is very unlikely to affect your code. It's relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the <code>deferEvaluation</code> option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the <code>peek</code> function described above.</p>
<h1 id="determining-if-a-property-is-a-computed-observable">Determining if a property is a computed observable</h1>
<p>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.isComputed</span></code> to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> myObject) {
  <span class="hljs-keyword">if</span> (myObject.hasOwnProperty(prop) &amp;&amp; !ko.isComputed(myObject[prop])) {
      result[prop] = myObject[prop];
  }
}
</code></pre>
<p>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</p>
<ul>
<li><code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.isObservable</span></code> - returns true for observables, observable arrays, and all computed observables.</li>
<li><code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.isWriteableObservable</span></code> - returns true for observable, observable arrays, and writeable computed observables.</li>
</ul>
<h1 id="computed-observable-reference">Computed Observable Reference</h1>
<p>The following documentation describes how to construct and work with computed observables.</p>
<h2 id="constructing-a-computed-observable">Constructing a computed observable</h2>
<p>A computed observable can be constructed using one of the following forms:</p>
<ol>
<li><p><code class="lang-stylus">ko.<span class="hljs-function"><span class="hljs-title">computed</span><span class="hljs-params">( evaluator [, targetObject, options] )</span></span></code> --- This form supports the most common case of creating a computed observable.</p>
<ul>
<li><code>evaluator</code> --- A function that is used to evaluate the computed observable's current value.</li>
<li><code>targetObject</code> --- If given, defines the value of <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> whenever KO invokes your callback functions. See the section on <a href="#managing_this">managing <code class="lang-actionscript"><span class="hljs-keyword">this</span></code></a> for more information.</li>
<li><code class="lang-apache"><span class="hljs-keyword"><span class="hljs-common">options</span></span></code> --- An object with further properties for the computed observable. See the full list below.</li>
</ul>
</li>
<li><p><code class="lang-stylus">ko.<span class="hljs-function"><span class="hljs-title">computed</span><span class="hljs-params">( options )</span></span></code> --- This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</p>
<ul>
<li><code class="lang-applescript"><span class="hljs-command">read</span></code> --- Required. A function that is used to evaluate the computed observable's current value.</li>
<li><code class="lang-applescript"><span class="hljs-command">write</span></code> --- Optional. If given, makes the computed observable writeable. This is a function that receives values that other code is trying to write to your computed observable. It's up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</li>
<li><code class="lang-sqf"><span class="hljs-built_in">owner</span></code> --- Optional. If given, defines the value of <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> whenever KO invokes your <code class="lang-applescript"><span class="hljs-command">read</span></code> or <code class="lang-applescript"><span class="hljs-command">write</span></code> callbacks.</li>
<li><code>deferEvaluation</code> --- Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</li>
<li><code>disposeWhen</code> --- Optional. If given, this function is executed on each re-evaluation to determine if the computed observable should be disposed. A <code class="lang-actionscript"><span class="hljs-literal">true</span></code>-ish result will trigger disposal of the computed observable.</li>
<li><code>disposeWhenNodeIsRemoved</code> --- Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the <code class="lang-cpp"><span class="hljs-keyword">template</span></code> and control-flow bindings.</li>
</ul>
</li>
</ol>
<h2 id="using-a-computed-observable">Using a computed observable</h2>
<p>A computed observable provides the following functions:</p>
<ul>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">dispose</span><span class="hljs-params">()</span></span></code> --- Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won't be cleaned.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">extend</span><span class="hljs-params">(extenders)</span></span></code> --- Applies the given <a href="extenders.html">extenders</a> to the computed observable.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">getDependenciesCount</span><span class="hljs-params">()</span></span></code> --- Returns the current number of dependencies of the computed observable.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">getSubscriptionsCount</span><span class="hljs-params">()</span></span></code> --- Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">isActive</span><span class="hljs-params">()</span></span></code> --- Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">peek</span><span class="hljs-params">()</span></span></code> --- Returns the current value of the computed observable without creating a dependency (see the section above on <a href="#controlling_dependencies_using_peek"><code>peek</code></a>).</li>
<li><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">subscribe</span><span class="hljs-params">( callback [,callbackTarget, event] )</span></span></code> --- Registers a <a href="observables.html#explicitly_subscribing_to_observables">manual subscription</a> to be notified of changes to the computed observable.</li>
</ul>
<h2 id="using-the-computed-context">Using the computed context</h2>
<p>During the execution of a computed observable's evaluator function, you can access <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computedContext</span></code> to get information about the current computed property. It provides the following functions:</p>
<ul>
<li><p><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">isInitial</span><span class="hljs-params">()</span></span></code> --- A function that returns <code class="lang-actionscript"><span class="hljs-literal">true</span></code> if called during the first ever evaluation of the current computed observable, or <code class="lang-actionscript"><span class="hljs-literal">false</span></code> otherwise.</p>
</li>
<li><p><code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">getDependenciesCount</span><span class="hljs-params">()</span></span></code> --- Returns the number of dependencies of the computed observable detected so far during the current evaluation.</p>
<ul>
<li>Note: <code class="lang-stylus">ko<span class="hljs-class">.computedContext</span><span class="hljs-class">.getDependenciesCount</span>()</code> is equivalent to calling <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">getDependenciesCount</span><span class="hljs-params">()</span></span></code> on the computed observable itself. The reason that it also exists on <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computedContext</span></code> is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myComputed = ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ... Omitted: read some data that might be observable ...</span>

    <span class="hljs-comment">// Now let's inspect ko.computedContext</span>
    <span class="hljs-keyword">var</span> isFirstEvaluation = ko.computedContext.isInitial(),
        dependencyCount = ko.computedContext.getDependenciesCount(),
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Evaluating "</span> + (isFirstEvaluation ? <span class="hljs-string">"for the first time"</span> : <span class="hljs-string">"again"</span>));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"By now, this computed has "</span> + dependencyCount + <span class="hljs-string">" dependencies"</span>);

    <span class="hljs-comment">// ... Omitted: return the result ...</span>
});
</code></pre>
<p>These facilities are typically useful only in advanced scenarios, for example when your computed observable's primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</p>
<p><em>Note: Computed observables were once called "dependent observables", but have since been renamed i.e. <code class="lang-fix"><span class="hljs-attribute">ko.dependentObservable ==</span>=<span class="hljs-string"> ko.computed</span></code></em></p>


  <footer>
    <p>Generated with Metalsmith &mdash; <a href="http://metalsmith.io">http://metalsmith.io</a></p>
  </footer>

</body>
</html>
