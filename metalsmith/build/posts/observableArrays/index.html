<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Observable Arrays</title>
  <meta name="description" content="It&#x27;s about saying »Hello« to the world.">
	<link rel="stylesheet" href="/assets/css/code.css">
</head>
<body>
  <header>
    <p>
      <a href="/">Home</a>
    </p>
  </header>
  <h1>Observable Arrays</h1>

  <p>If you want to detect and respond to changes on one object, you'd use <a href="#observables">observables</a>. If you want to detect and respond to changes of a <em>collection of things</em>, use an <code>observableArray</code>. This is useful in many scenarios where you're displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</p>
<h3 id="example">Example</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myObservableArray = ko.observableArray();    <span class="hljs-comment">// Initially an empty array</span>
myObservableArray.push(<span class="hljs-string">'Some value'</span>);            <span class="hljs-comment">// Adds the value and notifies observers</span>
</code></pre>
<p>To see how you can bind the <code>observableArray</code> to a UI and let the user modify it, see <a href="../examples/simpleList.html">the simple list example</a>.</p>
<h3 id="key-point-an-observablearray-tracks-which-objects-are-in-the-array-not-the-state-of-those-objects">Key point: An observableArray tracks which objects are <em>in</em> the array, <em>not</em> the state of those objects</h3>
<p>Simply putting an object into an <code>observableArray</code> doesn't make all of that object's properties themselves observable. Of course, you can make those properties observable if you wish, but that's an independent choice. An <code>observableArray</code> just tracks which objects it holds, and notifies listeners when objects are added or removed.</p>
<h2 id="prepopulating-an-observablearray">Prepopulating an observableArray</h2>
<p>If you want your observable array <strong>not</strong> to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// This observable array initially contains three objects</span>
<span class="hljs-keyword">var</span> anotherObservableArray = ko.observableArray([
  { name: <span class="hljs-string">"Bungle"</span>, type: <span class="hljs-string">"Bear"</span> },
  { name: <span class="hljs-string">"George"</span>, type: <span class="hljs-string">"Hippo"</span> },
  { name: <span class="hljs-string">"Zippy"</span>, type: <span class="hljs-string">"Unknown"</span> }
]);
</code></pre>
<h2 id="reading-information-from-an-observablearray">Reading information from an observableArray</h2>
<p>Behind the scenes, an <code>observableArray</code> is actually an <a href="#observables">observable</a> whose value is an array (plus, <code>observableArray</code> adds some additional features described below). So, you can get the underlying JavaScript array by invoking the <code>observableArray</code> as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</p>
<pre><code class="lang-javascript">alert(<span class="hljs-string">'The length of the array is '</span> + myObservableArray().length);
alert(<span class="hljs-string">'The first element is '</span> + myObservableArray()[<span class="hljs-number">0</span>]);
</code></pre>
<p>Technically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there's a better alternative. KO's <code>observableArray</code> has equivalent functions of its own, and they're more useful because:</p>
<ol>
<li>They work on all targeted browsers. (For example, the native JavaScript <code>indexOf</code> function doesn't work on IE 8 or earlier, but KO's <code>indexOf</code> works everywhere.)</li>
<li>For functions that modify the contents of the array, such as <code class="lang-avrasm"><span class="hljs-keyword">push</span></code> and <code class="lang-perl"><span class="hljs-keyword">splice</span></code>, KO's methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</li>
<li>The syntax is more convenient. To call KO's <code class="lang-avrasm"><span class="hljs-keyword">push</span></code> method, just write <code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">(...)</span></span></code>. This is slightly nicer than calling the underlying array's <code class="lang-avrasm"><span class="hljs-keyword">push</span></code> method by writing <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">myObservableArray</span><span class="hljs-params">()</span></span>.<span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">(...)</span></span></code>.</li>
</ol>
<p>The rest of this page describes <code>observableArray</code>'s functions for reading and writing array information.</p>
<h3 id="indexof">indexOf</h3>
<p>The <code>indexOf</code> function returns the index of the first array item that equals your parameter. For example, <code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">indexOf</span><span class="hljs-params">(<span class="hljs-string">'Blah'</span>)</span></span></code> will return the zero-based index of the first array entry that equals <code>Blah</code>, or the value <code class="lang-cpp">-<span class="hljs-number">1</span></code> if no matching value was found.</p>
<h3 id="slice">slice</h3>
<p>The <code>slice</code> function is the <code>observableArray</code> equivalent of the native JavaScript <code>slice</code> function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling <code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">slice</span><span class="hljs-params">(...)</span></span></code> is equivalent to calling the same method on the underlying array (i.e., <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">myObservableArray</span><span class="hljs-params">()</span></span>.<span class="hljs-function"><span class="hljs-title">slice</span><span class="hljs-params">(...)</span></span></code>).</p>
<h2 id="manipulating-an-observablearray">Manipulating an observableArray</h2>
<p><code>observableArray</code> exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</p>
<h3 id="pop-push-shift-unshift-reverse-sort-splice">pop, push, shift, unshift, reverse, sort, splice</h3>
<p>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</p>
<ul>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-string">'Some new value'</span>)</span></span></code> adds a new item to the end of array</li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span></code> removes the last value from the array and returns it</li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">unshift</span><span class="hljs-params">(<span class="hljs-string">'Some new value'</span>)</span></span></code> inserts a new item at the beginning of the array</li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">shift</span><span class="hljs-params">()</span></span></code> removes the first value from the array and returns it</li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">reverse</span><span class="hljs-params">()</span></span></code> reverses the order of the array</li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">()</span></span></code> sorts the array contents.<ul>
<li>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of 'person' objects by last name, you could write <code class="lang-swift">myObservableArray.<span class="hljs-built_in">sort</span>(function(<span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>) { <span class="hljs-keyword">return</span> <span class="hljs-keyword">left</span>.lastName == <span class="hljs-keyword">right</span>.lastName ? <span class="hljs-number">0</span> : (<span class="hljs-keyword">left</span>.lastName &lt; <span class="hljs-keyword">right</span>.lastName ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>) })</code></li>
</ul>
</li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">splice</span><span class="hljs-params">()</span></span></code> removes and returns a given number of elements starting from a given index. For example, <code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">splice</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span></span></code> removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</li>
</ul>
<p>For more details about these <code>observableArray</code> functions, see the equivalent documentation of the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2">standard JavaScript array functions</a>.</p>
<h3 id="remove-and-removeall">remove and removeAll</h3>
<p><code>observableArray</code> adds some more useful methods that aren't found on JavaScript arrays by default:</p>
<ul>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">remove</span><span class="hljs-params">(someItem)</span></span></code> removes all values that equal <code>someItem</code> and returns them as an array</li>
<li><code class="lang-actionscript">myObservableArray.remove(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{ <span class="hljs-keyword">return</span> item.age &lt; <span class="hljs-number">18</span> })</code> removes all values whose <code>age</code> property is less than 18, and returns them as an array</li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">removeAll</span><span class="hljs-params">([<span class="hljs-string">'Chad'</span>, <span class="hljs-number">132</span>, undefined])</span></span></code> removes all values that equal <code class="lang-actionscript"><span class="hljs-string">'Chad'</span></code>, <code class="lang-cpp"><span class="hljs-number">123</span></code>, or <code class="lang-actionscript"><span class="hljs-literal">undefined</span></code> and returns them as an array</li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">removeAll</span><span class="hljs-params">()</span></span></code> removes all values and returns them as an array</li>
</ul>
<h3 id="destroy-and-destroyall-note-usually-relevant-to-ruby-on-rails-developers-only-">destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</h3>
<p>The <code>destroy</code> and <code>destroyAll</code> functions are mainly intended as a convenience for developers using Ruby on Rails:</p>
<ul>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">destroy</span><span class="hljs-params">(someItem)</span></span></code> finds any objects in the array that equal <code>someItem</code> and gives them a special property called <code>_destroy</code> with value <code class="lang-actionscript"><span class="hljs-literal">true</span></code></li>
<li><code class="lang-actionscript">myObservableArray.destroy(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(someItem)</span> </span>{ <span class="hljs-keyword">return</span> someItem.age &lt; <span class="hljs-number">18</span> })</code> finds any objects in the array whose <code>age</code> property is less than 18, and gives those objects a special property called <code>_destroy</code> with value <code class="lang-actionscript"><span class="hljs-literal">true</span></code></li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">destroyAll</span><span class="hljs-params">([<span class="hljs-string">'Chad'</span>, <span class="hljs-number">132</span>, undefined])</span></span></code> finds any objects in the array that equal <code class="lang-actionscript"><span class="hljs-string">'Chad'</span></code>, <code class="lang-cpp"><span class="hljs-number">123</span></code>, or <code class="lang-actionscript"><span class="hljs-literal">undefined</span></code> and gives them a special property called <code>_destroy</code> with value <code class="lang-actionscript"><span class="hljs-literal">true</span></code></li>
<li><code class="lang-stylus">myObservableArray.<span class="hljs-function"><span class="hljs-title">destroyAll</span><span class="hljs-params">()</span></span></code> gives a special property called <code>_destroy</code> with value <code class="lang-actionscript"><span class="hljs-literal">true</span></code> to all objects in the array</li>
</ul>
<p>So, what's this <code>_destroy</code> thing all about? It's only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with <code>_destroy</code> set to <code class="lang-actionscript"><span class="hljs-literal">true</span></code>.</p>
<p>Note that when KO renders a <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding, it automatically hides any objects marked with <code>_destroy</code> equal to <code class="lang-actionscript"><span class="hljs-literal">true</span></code>. So, you can have some kind of "delete" button that invokes the <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">destroy</span><span class="hljs-params">(someItem)</span></span></code> method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</p>
<h2 id="delaying-and-or-suppressing-change-notifications">Delaying and/or suppressing change notifications</h2>
<p>Normally, an <code>observableArray</code> notifies its subscribers immediately, as soon as it's changed. But if an <code>observableArray</code> is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the <a href="#rateLimit-observable"><code>rateLimit</code> extender</a> like this:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Ensure it notifies about changes no more than once per 50-millisecond period</span>
myViewModel.myObservableArray.extend({ rateLimit: <span class="hljs-number">50</span> });
</code></pre>


  <footer>
    <p>Generated with Metalsmith &mdash; <a href="http://metalsmith.io">http://metalsmith.io</a></p>
  </footer>

</body>
</html>
