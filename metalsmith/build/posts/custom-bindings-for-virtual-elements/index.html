<p><em>Note: Creating custom bindings that support virtual elements is an advanced technique, typically used only when creating libraries of reusable bindings. It's not something you'll normally need to do when building applications with Knockout.</em></p>
<p>Knockout's <em>control flow bindings</em> (e.g., <a href="if-binding.html"><code class="lang-actionscript"><span class="hljs-keyword">if</span></code></a> and <a href="foreach-binding.html"><code class="lang-cmake"><span class="hljs-keyword">foreach</span></code></a>) can be applied not only to regular DOM elements, but also to "virtual" DOM elements defined by a special comment-based syntax. For example:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"heading"</span>&gt;</span>My heading<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- ko foreach: items --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: $data"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- /ko --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p>Custom bindings can work with virtual elements too, but to enable this, you must explicitly tell Knockout that your binding understands virtual elements, by using the <code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.allowedBindings</span></code> API.</p>
<h3 id="example">Example</h3>
<p>To get started, here's a custom binding that randomises the order of DOM nodes:</p>
<pre><code class="lang-javascript">ko.bindingHandlers.randomOrder = {
    init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem, valueAccessor</span>) </span>{
        <span class="hljs-comment">// Pull out each of the child elements into an array</span>
        <span class="hljs-keyword">var</span> childElems = [];
        <span class="hljs-keyword">while</span>(elem.firstChild)
            childElems.push(elem.removeChild(elem.firstChild));

        <span class="hljs-comment">// Put them back in a random order</span>
        <span class="hljs-keyword">while</span>(childElems.length) {
            <span class="hljs-keyword">var</span> randomIndex = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * childElems.length),
                chosenChild = childElems.splice(randomIndex, <span class="hljs-number">1</span>);
            elem.appendChild(chosenChild[<span class="hljs-number">0</span>]);
        }
    }
};
</code></pre>
<p>This works nicely with regular DOM elements. The following elements will be shuffled into a random order:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"randomOrder: true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>First<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Second<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Third<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>However, it does <em>not</em> work with virtual elements. If you try the following:</p>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- ko randomOrder: true --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>First<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Second<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Third<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-comment">&lt;!-- /ko --&gt;</span>
</code></pre>
<p>... then you'll get the error <code class="lang-delphi">The binding <span class="hljs-string">'randomOrder'</span> cannot be used <span class="hljs-keyword">with</span> <span class="hljs-keyword">virtual</span> elements</code>. Let's fix this. To make <code class="lang-pf"><span class="hljs-keyword">random</span>Order</code> usable with virtual elements, start by telling Knockout to allow it. Add the following:</p>
<pre><code class="lang-javascript">ko.virtualElements.allowedBindings.randomOrder = <span class="hljs-literal">true</span>;
</code></pre>
<p>Now there won't be an error. However, it still won't work properly, because our <code class="lang-pf"><span class="hljs-keyword">random</span>Order</code> binding is coded using normal DOM API calls (<code>firstChild</code>, <code>appendChild</code>, etc.) which don't understand virtual elements. This is the reason why KO requires you to explicitly opt in to virtual element support: unless your custom binding is coded using virtual element APIs, it's not going to work properly!</p>
<p>Let's update the code for <code class="lang-pf"><span class="hljs-keyword">random</span>Order</code>, this time using KO's virtual element APIs:</p>
<pre><code class="lang-javascript">ko.bindingHandlers.randomOrder = {
    init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem, valueAccessor</span>) </span>{
        <span class="hljs-comment">// Build an array of child elements</span>
        <span class="hljs-keyword">var</span> child = ko.virtualElements.firstChild(elem),
            childElems = [];
        <span class="hljs-keyword">while</span> (child) {
            childElems.push(child);
            child = ko.virtualElements.nextSibling(child);
        }

        <span class="hljs-comment">// Remove them all, then put them back in a random order</span>
        ko.virtualElements.emptyNode(elem);
        <span class="hljs-keyword">while</span>(childElems.length) {
            <span class="hljs-keyword">var</span> randomIndex = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * childElems.length),
                chosenChild = childElems.splice(randomIndex, <span class="hljs-number">1</span>);
            ko.virtualElements.prepend(elem, chosenChild[<span class="hljs-number">0</span>]);
        }
    }
};
</code></pre>
<p>Notice how, instead of using APIs like <code class="lang-css"><span class="hljs-tag">domElement</span><span class="hljs-class">.firstChild</span></code>, we're now using <code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.firstChild</span>(domOrVirtualElement)</code>. The <code class="lang-pf"><span class="hljs-keyword">random</span>Order</code> binding will now correctly work with virtual elements, e.g., <code class="lang-xml"><span class="hljs-comment">&lt;!-- ko randomOrder: true --&gt;</span>...<span class="hljs-comment">&lt;!-- /ko --&gt;</span></code>.</p>
<p>Also, <code class="lang-pf"><span class="hljs-keyword">random</span>Order</code> will still work with regular DOM elements, because all of the <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.virtualElements</span></code> APIs are backwardly compatible with regular DOM elements.</p>
<h3 id="tables-and-virtual-elements">Tables and Virtual Elements</h3>
<p>In some browsers you must be careful about virtual elements inside <code class="lang-apache"><span class="hljs-tag">&lt;tbody&gt;</span></code> and <code class="lang-apache"><span class="hljs-tag">&lt;thead&gt;</span></code> tags, since they may be "hoisted" out. For example:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">table</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- foreach: list  --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">td</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-title">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">tr</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- /foreach --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">table</span>&gt;</span>
</code></pre>
<p>may be interpreted by the browser as:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">table</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- foreach: list  --&gt;</span>
  <span class="hljs-comment">&lt;!-- /foreach --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">tbody</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">td</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-title">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">tbody</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">table</span>&gt;</span>
</code></pre>
<p>Be mindful of using virtual elements inside tables.</p>
<p>For more information on this caveat, see issue <a href="https://github.com/knockout/knockout/issues/1759">#1759</a>.</p>
<h3 id="virtual-element-apis">Virtual Element APIs</h3>
<p>Knockout provides the following functions for working with virtual elements.</p>
<ul>
<li><p><code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.allowedBindings</span></code></p>
<p>An object whose keys determine which bindings are usable with virtual elements. Set <code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.allowedBindings</span><span class="hljs-class">.mySuperBinding</span> = true</code> to allow <code>mySuperBinding</code> to be used with virtual elements.</p>
</li>
<li><p><code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.emptyNode</span>(containerElem)</code></p>
<p>Removes all child nodes from the real or virtual element <code>containerElem</code> (cleaning away any data associated with them to avoid memory leaks).</p>
</li>
<li><p><code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.firstChild</span>(containerElem)</code></p>
<p>Returns the first child of the real or virtual element <code>containerElem</code>, or <code class="lang-actionscript"><span class="hljs-literal">null</span></code> if there are no children.</p>
</li>
<li><p><code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.insertAfter</span>(containerElem, nodeToInsert, insertAfter)</code></p>
<p>Inserts <code>nodeToInsert</code> as a child of the real or virtual element <code>containerElem</code>, positioned immediately after <code>insertAfter</code> (where <code>insertAfter</code> must be a child of <code>containerElem</code>).</p>
</li>
<li><p><code class="lang-crmsh">ko.virtualElements.nextSibling(<span class="hljs-keyword">node</span><span class="hljs-identifier"></span><span class="hljs-title">)</span></code></p>
<p>Returns the sibling node that follows <code class="lang-crmsh"><span class="hljs-keyword">node</span><span class="hljs-identifier"></span><span class="hljs-title"></span></code> in its real or virtual parent element, or <code class="lang-actionscript"><span class="hljs-literal">null</span></code> if there is no following sibling.</p>
</li>
<li><p><code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.prepend</span>(containerElem, nodeToPrepend)</code></p>
<p>Inserts <code>nodeToPrepend</code> as the first child of the real or virtual element <code>containerElem</code>.</p>
</li>
<li><p><code class="lang-stylus">ko<span class="hljs-class">.virtualElements</span><span class="hljs-class">.setDomNodeChildren</span>(containerElem, arrayOfNodes)</code></p>
<p>Removes all child nodes from the real or virtual element <code>containerElem</code> (in the process, cleaning away any data associated with them to avoid memory leaks), and then inserts all of the nodes from <code>arrayOfNodes</code> as its new children.</p>
</li>
</ul>
<p>Notice that this is <em>not</em> intended to be a complete replacement to the full set of regular DOM APIs. Knockout provides only a minimal set of virtual element APIs to make it possible to perform the kinds of transformations needed when implementing control flow bindings.</p>
