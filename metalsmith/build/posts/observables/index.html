<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Observables</title>
  <meta name="description" content="It&#x27;s about saying »Hello« to the world.">
	<link rel="stylesheet" href="/assets/css/code.css">
</head>
<body>
  <header>
    <p>
      <a href="/">Home</a>
    </p>
  </header>
  <h1>Observables</h1>

  <p>Knockout is built around three core features:</p>
<ol>
<li>Observables and dependency tracking</li>
<li>Declarative bindings</li>
<li>Templating</li>
</ol>
<p>On this page, you'll learn about the first of these three. But before that, let's examine the MVVM pattern and the concept of a <em>view model</em>.</p>
<h1 id="mvvm-and-view-models">MVVM and View Models</h1>
<p><em>Model-View-View Model (MVVM)</em> is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:</p>
<ul>
<li><p>A <em>model</em>: your application's stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.</p>
</li>
<li><p>A <em>view model</em>: a pure-code representation of the data and operations on a UI. For example, if you're implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.</p>
<p>Note that this is not the UI itself: it doesn't have any concept of buttons or display styles. It's not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.</p>
</li>
<li><p>A <em>view</em>: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.</p>
<p>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</p>
</li>
</ul>
<p>To create a view model with KO, just declare any JavaScript object. For example,</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myViewModel = {
    personName: <span class="hljs-string">'Bob'</span>,
    personAge: <span class="hljs-number">123</span>
};
</code></pre>
<p>You can then create a very simple <em>view</em> of this view model using a declarative binding. For example, the following markup displays the <code>personName</code> value:</p>
<pre><code class="lang-html">The name is <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"text: personName"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
</code></pre>
<h2 id="activating-knockout">Activating Knockout</h2>
<p>The <code class="lang-fortran"><span class="hljs-type">data</span>-<span class="hljs-keyword">bind</span></code> attribute isn't native to HTML, though it is perfectly OK (it's strictly compliant in HTML 5, and causes no problems with HTML 4 even though a validator will point out that it's an unrecognized attribute). But since the browser doesn't know what it means, you need to activate Knockout to make it take effect.</p>
<p>To activate Knockout, add the following line to a <code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="undefined"></span></code> block:</p>
<pre><code class="lang-javascript">ko.applyBindings(myViewModel);
</code></pre>
<p>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as <a href="http://api.jquery.com/jQuery/#jQuery3">jQuery's <code>$</code> function</a>.</p>
<p>That does it! Now, your view will display as if you'd written the following HTML:</p>
<pre><code class="lang-html">The name is <span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>Bob<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
</code></pre>
<p>In case you're wondering what the parameters to <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.applyBindings</span></code> do,</p>
<ul>
<li><p>The first parameter says what view model object you want to use with the declarative bindings it activates</p>
</li>
<li><p>Optionally, you can pass a second parameter to define which part of the document you want to search for <code class="lang-fortran"><span class="hljs-type">data</span>-<span class="hljs-keyword">bind</span></code> attributes. For example, <code class="lang-stylus">ko.<span class="hljs-function"><span class="hljs-title">applyBindings</span><span class="hljs-params">(myViewModel, document.getElementById(<span class="hljs-string">'someElementId'</span>)</span></span>)</code>. This restricts the activation to the element with ID <code>someElementId</code> and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.</p>
</li>
</ul>
<p>Pretty simple, really.</p>
<h1 id="observables">Observables</h1>
<p>OK, you've seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as <em>observables</em>, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</p>
<p>For example, rewrite the preceding view model object as follows:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myViewModel = {
    personName: ko.observable(<span class="hljs-string">'Bob'</span>),
    personAge: ko.observable(<span class="hljs-number">123</span>)
};
</code></pre>
<p>You don't have to change the view at all - the same <code class="lang-fortran"><span class="hljs-type">data</span>-<span class="hljs-keyword">bind</span></code> syntax will keep working. The difference is that it's now capable of detecting changes, and when it does, it will update the view automatically.</p>
<h2 id="reading-and-writing-observables">Reading and writing observables</h2>
<p>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.observable</span></code> objects are actually <em>functions</em>.</p>
<ul>
<li><p>To <strong>read</strong> the observable's current value, just call the observable with no parameters. In this example, <code class="lang-stylus">myViewModel.<span class="hljs-function"><span class="hljs-title">personName</span><span class="hljs-params">()</span></span></code> will return <code class="lang-actionscript"><span class="hljs-string">'Bob'</span></code>, and <code class="lang-stylus">myViewModel.<span class="hljs-function"><span class="hljs-title">personAge</span><span class="hljs-params">()</span></span></code> will return <code class="lang-cpp"><span class="hljs-number">123</span></code>.</p>
</li>
<li><p>To <strong>write</strong> a new value to the observable, call the observable and pass the new value as a parameter. For example, calling <code class="lang-stylus">myViewModel.<span class="hljs-function"><span class="hljs-title">personName</span><span class="hljs-params">(<span class="hljs-string">'Mary'</span>)</span></span></code> will change the name value to <code class="lang-actionscript"><span class="hljs-string">'Mary'</span></code>.</p>
</li>
<li><p>To write values to <strong>multiple observable properties</strong> on a model object, you can use <em>chaining syntax</em>. For example, <code class="lang-stylus">myViewModel.<span class="hljs-function"><span class="hljs-title">personName</span><span class="hljs-params">(<span class="hljs-string">'Mary'</span>)</span></span>.<span class="hljs-function"><span class="hljs-title">personAge</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span></code> will change the name value to <code class="lang-actionscript"><span class="hljs-string">'Mary'</span></code> <em>and</em> the age value to <code class="lang-cpp"><span class="hljs-number">50</span></code>.</p>
</li>
</ul>
<p>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That's what many of KO's built-in bindings do internally. So, when you wrote <code class="lang-fortran"><span class="hljs-type">data</span>-<span class="hljs-keyword">bind</span>=<span class="hljs-string">"text: personName"</span></code>, the <code class="lang-applescript"><span class="hljs-type">text</span></code> binding registered itself to be notified when <code>personName</code> changes (assuming it's an observable value, which it is now).</p>
<p>When you change the name value to <code class="lang-actionscript"><span class="hljs-string">'Mary'</span></code> by calling <code class="lang-stylus">myViewModel.<span class="hljs-function"><span class="hljs-title">personName</span><span class="hljs-params">(<span class="hljs-string">'Mary'</span>)</span></span></code>, the <code class="lang-applescript"><span class="hljs-type">text</span></code> binding will automatically update the text contents of the associated DOM element. That's how changes to the view model automatically propagate to the view.</p>
<h2 id="explicitly-subscribing-to-observables">Explicitly subscribing to observables</h2>
<p><em>You won't normally need to set up subscriptions manually, so beginners should skip this section.</em></p>
<p>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their <code>subscribe</code> function. For example:</p>
<pre><code class="lang-javascript">myViewModel.personName.subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) </span>{
    alert(<span class="hljs-string">"The person's new name is "</span> + newValue);
});
</code></pre>
<p>The <code>subscribe</code> function is how many parts of KO work internally. Most of the time you don't need to use this, because the built-in bindings and templating system take care of managing subscriptions.</p>
<p>The <code>subscribe</code> function accepts three parameters: <code class="lang-haxe"><span class="hljs-keyword">callback</span></code> is the function that is called whenever the notification happens, <code class="lang-aspectj"><span class="hljs-keyword">target</span></code> (optional) defines the value of <code class="lang-actionscript"><span class="hljs-keyword">this</span></code> in the callback function, and <code class="lang-cs"><span class="hljs-keyword">event</span></code> (optional; default is <code class="lang-1c"><span class="hljs-string">"change"</span></code>) is the name of the event to receive notification for.</p>
<p>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its <code>dispose</code> function, e.g.:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> subscription = myViewModel.personName.subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) </span>{ <span class="hljs-comment">/* do stuff */</span> });
<span class="hljs-comment">// ...then later...</span>
subscription.dispose(); <span class="hljs-comment">// I no longer want notifications</span>
</code></pre>
<p>If you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the <code>beforeChange</code> event. For example:</p>
<pre><code class="lang-javascript">myViewModel.personName.subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">oldValue</span>) </span>{
    alert(<span class="hljs-string">"The person's previous name is "</span> + oldValue);
}, <span class="hljs-literal">null</span>, <span class="hljs-string">"beforeChange"</span>);
</code></pre>
<p>Note: Knockout does not guarantee that the <code>beforeChange</code> and <code class="lang-sql"><span class="hljs-operator"><span class="hljs-keyword">change</span></span></code> events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it's up to you to use a subscription to capture and track it.</p>
<h2 id="forcing-observables-to-always-notify-subscribers">Forcing observables to always notify subscribers</h2>
<p>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in <code class="lang-oxygene"><span class="hljs-keyword">notify</span></code> <a href="extenders.html">extender</a> to ensure that an observable's subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</p>
<pre><code class="lang-javascript">myViewModel.personName.extend({ notify: <span class="hljs-string">'always'</span> });
</code></pre>
<h2 id="delaying-and-or-suppressing-change-notifications">Delaying and/or suppressing change notifications</h2>
<p>Normally, an observable notifies its subscribers immediately, as soon as it's changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable's change notifications. This is accomplished using the <a href="rateLimit-observable.html"><code>rateLimit</code> extender</a> like this:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Ensure it notifies about changes no more than once per 50-millisecond period</span>
myViewModel.personName.extend({ rateLimit: <span class="hljs-number">50</span> });
</code></pre>


  <footer>
    <p>Generated with Metalsmith &mdash; <a href="http://metalsmith.io">http://metalsmith.io</a></p>
  </footer>

</body>
</html>
