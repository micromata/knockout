<p>You're not limited to using the built-in bindings like <code>click</code>, <code class="lang-ceylon"><span class="hljs-keyword">value</span></code>, and so on --- you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.</p>
<p>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the <a href="../examples/grid.html">grid example</a>).</p>
<h3 id="registering-your-binding">Registering your binding</h3>
<p>To register a binding, add it as a subproperty of <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.bindingHandlers</span></code>:</p>
<pre><code class="lang-javascript">ko.bindingHandlers.yourBindingName = {
    init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, valueAccessor, allBindings, viewModel, bindingContext</span>) </span>{
        <span class="hljs-comment">// This will be called when the binding is first applied to an element</span>
        <span class="hljs-comment">// Set up any initial state, event handlers, etc. here</span>
    },
    update: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, valueAccessor, allBindings, viewModel, bindingContext</span>) </span>{
        <span class="hljs-comment">// This will be called once when the binding is first applied to an element,</span>
        <span class="hljs-comment">// and again whenever the associated observable changes value.</span>
        <span class="hljs-comment">// Update the DOM element based on the supplied values here.</span>
    }
};
</code></pre>
<p>... and then you can use it on any number of DOM elements:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"yourBindingName: someValue"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>Note: you don't actually have to provide both <code class="lang-swift"><span class="hljs-keyword">init</span></code> <em>and</em> <code class="lang-q"><span class="hljs-keyword">update</span></code> callbacks --- you can just provide one or the other if that's all you need.</p>
<h3 id="the-update-callback">The "update" callback</h3>
<p>Whenever the associated observable changes, KO will call your <code class="lang-q"><span class="hljs-keyword">update</span></code> callback, passing the following parameters:</p>
<ul>
<li><code class="lang-livecodeserver"><span class="hljs-keyword">element</span></code> --- The DOM element involved in this binding</li>
<li><code>valueAccessor</code> --- A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">valueAccessor</span><span class="hljs-params">()</span></span></code>) to get the current model property value. To easily accept both observable and plain values, call <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.unwrap</span></code> on the returned value.</li>
<li><code class="lang-pf"><span class="hljs-literal">all</span>Bindings</code> --- A JavaScript object that you can use to access all the model values bound to this DOM element. Call <code class="lang-stylus">allBindings.<span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-string">'name'</span>)</span></span></code> to retrieve the value of the <code class="lang-applescript"><span class="hljs-property">name</span></code> binding (returns <code class="lang-actionscript"><span class="hljs-literal">undefined</span></code> if the binding doesn't exist); or <code class="lang-stylus">allBindings.<span class="hljs-function"><span class="hljs-title">has</span><span class="hljs-params">(<span class="hljs-string">'name'</span>)</span></span></code> to determine if the <code class="lang-applescript"><span class="hljs-property">name</span></code> binding is present for the current element.</li>
<li><code>viewModel</code> --- This parameter is deprecated in Knockout 3.x. Use <code class="lang-xquery">bindingContext.<span class="hljs-variable">$data</span></code> or <code class="lang-xquery">bindingContext.<span class="hljs-variable">$rawData</span></code> to access the view model instead.</li>
<li><code>bindingContext</code> --- An object that holds the <a href="http://knockoutjs.com/documentation/binding-context.html">binding context</a> available to this element's bindings. This object includes special properties including <code class="lang-xquery"><span class="hljs-variable">$parent</span></code>, <code class="lang-xquery"><span class="hljs-variable">$parents</span></code>, and <code class="lang-xquery"><span class="hljs-variable">$root</span></code> that can be used to access data that is bound against ancestors of this context.</li>
</ul>
<p>For example, you might have been controlling an element's visibility using the <code class="lang-scss"><span class="hljs-value">visible</span></code> binding, but now you want to go a step further and animate the transition. You want elements to slide into and out of existence according to the value of an observable. You can do this by writing a custom binding that calls jQuery's <code>slideUp</code>/<code>slideDown</code> functions:</p>
<pre><code class="lang-javascript">ko.bindingHandlers.slideVisible = {
    update: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, valueAccessor, allBindings</span>) </span>{
        <span class="hljs-comment">// First get the latest data that we're bound to</span>
        <span class="hljs-keyword">var</span> value = valueAccessor();

        <span class="hljs-comment">// Next, whether or not the supplied model property is observable, get its current value</span>
        <span class="hljs-keyword">var</span> valueUnwrapped = ko.unwrap(value);

        <span class="hljs-comment">// Grab some more data from another binding property</span>
        <span class="hljs-keyword">var</span> duration = allBindings.get(<span class="hljs-string">'slideDuration'</span>) || <span class="hljs-number">400</span>; <span class="hljs-comment">// 400ms is default duration unless otherwise specified</span>

        <span class="hljs-comment">// Now manipulate the DOM element</span>
        <span class="hljs-keyword">if</span> (valueUnwrapped == <span class="hljs-literal">true</span>)
            $(element).slideDown(duration); <span class="hljs-comment">// Make the element visible</span>
        <span class="hljs-keyword">else</span>
            $(element).slideUp(duration);   <span class="hljs-comment">// Make the element invisible</span>
    }
};
</code></pre>
<p>Now you can use this binding as follows:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"slideVisible: giftWrap, slideDuration:600"</span>&gt;</span>You have selected the option<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"checkbox"</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"checked: giftWrap"</span> /&gt;</span> Gift wrap<span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> viewModel = {
    giftWrap: ko.observable(<span class="hljs-literal">true</span>)
};
ko.applyBindings(viewModel);
</code></pre>
<p>Of course, this is a lot of code at first glance, but once you've created your custom bindings they can very easily be reused in many places.</p>
<h3 id="the-init-callback">The "init" callback</h3>
<p>Knockout will call your <code class="lang-swift"><span class="hljs-keyword">init</span></code> function once for each DOM element that you use the binding on. There are two main uses for <code class="lang-swift"><span class="hljs-keyword">init</span></code>:</p>
<ul>
<li>To set any initial state for the DOM element</li>
<li>To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable</li>
</ul>
<p>KO will pass exactly the same set of parameters that it passes to <a href="#the_update_callback">the <code class="lang-q"><span class="hljs-keyword">update</span></code> callback</a>.</p>
<p>Continuing the previous example, you might want <code>slideVisible</code> to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state. You could do that as follows:</p>
<pre><code class="lang-javascript">ko.bindingHandlers.slideVisible = {
    init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, valueAccessor</span>) </span>{
        <span class="hljs-keyword">var</span> value = ko.unwrap(valueAccessor()); <span class="hljs-comment">// Get the current value of the current property we're bound to</span>
        $(element).toggle(value); <span class="hljs-comment">// jQuery will hide/show the element depending on whether "value" or true or false</span>
    },
    update: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, valueAccessor, allBindings</span>) </span>{
        <span class="hljs-comment">// Leave as before</span>
    }
};
</code></pre>
<p>This means that if <code>giftWrap</code> was defined with the initial state <code class="lang-actionscript"><span class="hljs-literal">false</span></code> (i.e., <code class="lang-stylus">giftWrap: ko.<span class="hljs-function"><span class="hljs-title">observable</span><span class="hljs-params">(false)</span></span></code>) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.</p>
<h3 id="modifying-observables-after-dom-events">Modifying observables after DOM events</h3>
<p>You've already seen how to use <code class="lang-q"><span class="hljs-keyword">update</span></code> so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.</p>
<p>You can use the <code class="lang-swift"><span class="hljs-keyword">init</span></code> callback as a place to register an event handler that will cause changes to the associated observable. For example,</p>
<pre><code class="lang-javascript">ko.bindingHandlers.hasFocus = {
    init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, valueAccessor</span>) </span>{
        $(element).focus(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> value = valueAccessor();
            value(<span class="hljs-literal">true</span>);
        });
        $(element).blur(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> value = valueAccessor();
            value(<span class="hljs-literal">false</span>);
        });
    },
    update: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, valueAccessor</span>) </span>{
        <span class="hljs-keyword">var</span> value = valueAccessor();
        <span class="hljs-keyword">if</span> (ko.unwrap(value))
            element.focus();
        <span class="hljs-keyword">else</span>
            element.blur();
    }
};
</code></pre>
<p>Now you can both read and write the "focusedness" of an element by binding it to an observable:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"hasFocus: editingName"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Showing that we can both read and write the focus state --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"visible: editingName"</span>&gt;</span>You're editing the name<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">"enable: !editingName(), click:function() { editingName(true) }"</span>&gt;</span>Edit name<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> viewModel = {
    editingName: ko.observable()
};
ko.applyBindings(viewModel);
</code></pre>
<h3 id="note-supporting-virtual-elements">Note: Supporting virtual elements</h3>
<p>If you want a custom binding to be usable with Knockout's <em>virtual elements</em> syntax, e.g.:</p>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- ko mybinding: somedata --&gt;</span> ... <span class="hljs-comment">&lt;!-- /ko --&gt;</span>
</code></pre>
<p>... then see <a href="#custom-bindings-for-virtual-elements">the documentation for virtual elements</a>.</p>
