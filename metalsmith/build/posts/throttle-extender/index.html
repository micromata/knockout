<p><em>Note: This throttle API is deprecated as of Knockout 3.1.0. Please use the <a href="#rateLimit-observable"><code>rateLimit</code> extender</a> for similar functionality.</em></p>
<p>Normally, <a href="#computedObservables">computed observables</a> are re-evaluated <em>synchronously</em>, as soon as each of their dependencies change. The <code>throttle</code> extender, however, causes a computed observable to delay re-evaluation until its dependencies have stopped changing for a specified period of time. Throttled computed observables therefore update <em>asychronously</em>.</p>
<p>The main uses cases for throttling are:</p>
<ul>
<li>Making things respond after a certain delay</li>
<li>Combining multiple changes into a single re-evaluation (also known as "atomic updates")</li>
</ul>
<p>You'll find examples of these below.</p>
<h3 id="example-1-the-basics">Example 1: The basics</h3>
<p>Consider the computed observable in the following code:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> name = ko.observable(<span class="hljs-string">'Bert'</span>);

<span class="hljs-keyword">var</span> upperCaseName = ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> name().toUpperCase();
});
</code></pre>
<p>Normally, if you update <code class="lang-applescript"><span class="hljs-property">name</span></code> as follows:</p>
<pre><code class="lang-javascript">name(<span class="hljs-string">'The New Bert'</span>);
</code></pre>
<p>... then <code>upperCaseName</code> will be recomputed immediately, before your next line of code runs. But if you had instead defined <code>upperCaseName</code> using <code>throttle</code> as follows:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> upperCaseName = ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> name().toUpperCase();
}).extend({ throttle: <span class="hljs-number">500</span> });
</code></pre>
<p>... then <code>upperCaseName</code> would not be recomputed immediately when <code class="lang-applescript"><span class="hljs-property">name</span></code> changes --- instead, it would wait for 500 milliseconds (half a second) before recomputing its value and then notifying any associated UI. Each time <code class="lang-applescript"><span class="hljs-property">name</span></code> changes, that timeout is reset back to zero, so the re-evaluation only occurs once <code class="lang-applescript"><span class="hljs-property">name</span></code> has stopped changing for at least half a second.</p>
<h3 id="example-2-doing-something-when-the-user-stops-typing">Example 2: Doing something when the user stops typing</h3>
<p>In this live example, there's an <code>instantaneousValue</code> observable that reacts immediately when you press a key. This is then wrapped inside a <code>throttledValue</code> computed observable that's configured to react only when you stop typing for at least 400 milliseconds.</p>
<p>Try it:</p>
<p><live-example params="id: &quot;throttle-binding&quot;"></live-example></p>
<h3 id="example-3-avoiding-multiple-ajax-requests">Example 3: Avoiding multiple Ajax requests</h3>
<p>The following model represents data that you could render as a paged grid:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GridViewModel</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.pageSize = ko.observable(<span class="hljs-number">20</span>);
    <span class="hljs-keyword">this</span>.pageIndex = ko.observable(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">this</span>.currentPageData = ko.observableArray();

    <span class="hljs-comment">// Query /Some/Json/Service whenever pageIndex or pageSize changes,</span>
    <span class="hljs-comment">// and use the results to update currentPageData</span>
    ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> params = { page: <span class="hljs-keyword">this</span>.pageIndex(), size: <span class="hljs-keyword">this</span>.pageSize() };
        $.getJSON(<span class="hljs-string">'/Some/Json/Service'</span>, params, <span class="hljs-keyword">this</span>.currentPageData);
    }, <span class="hljs-keyword">this</span>);
}
</code></pre>
<p>Because the <code class="lang-css"><span class="hljs-tag">ko</span><span class="hljs-class">.computed</span></code> evaluates both <code>pageIndex</code> and <code>pageSize</code>, it becomes dependent on both of them. So, this code will use jQuery's <a href="http://api.jquery.com/jQuery.getJSON/"><code class="lang-crystal"><span class="hljs-variable">$.</span>getJSON</code> function</a> to reload <code>currentPageData</code> when the <code>GridViewModel</code> is first instantiated <em>and</em> whenever the <code>pageIndex</code> or <code>pageSize</code> properties are later changed.</p>
<p>This is very simple and elegant (and it's trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. What if you want to change both <code>pageIndex</code> and <code>pageSize</code> at once? You might add the following function to <code>GridViewModel</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.setPageSize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newPageSize</span>) </span>{
    <span class="hljs-comment">// Whenever you change the page size, we always reset the page index to 1</span>
    <span class="hljs-keyword">this</span>.pageSize(newPageSize);
    <span class="hljs-keyword">this</span>.pageIndex(<span class="hljs-number">1</span>);
}
</code></pre>
<p>The problem is that this will cause <em>two</em> simultaneous Ajax requests: the first one will start when you update <code>pageSize</code>, and the second one will start immediately afterwards when you update <code>pageIndex</code>. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.</p>
<p>Throttling is an elegant solution. You can add an arbitrarily short but nonzero throttle timeout (e.g., 1 millisecond), and then any sequence of synchronous changes to dependencies will only trigger <em>one</em> re-evaluation of your computed observable. For example,</p>
<pre><code class="lang-javascript">ko.computed(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// This evaluation logic is exactly the same as before</span>
    <span class="hljs-keyword">var</span> params = { page: <span class="hljs-keyword">this</span>.pageIndex(), size: <span class="hljs-keyword">this</span>.pageSize() };
    $.getJSON(<span class="hljs-string">'/Some/Json/Service'</span>, params, <span class="hljs-keyword">this</span>.currentPageData);
}, <span class="hljs-keyword">this</span>).extend({ throttle: <span class="hljs-number">1</span> });
</code></pre>
<p>Now you can update <code>pageIndex</code> and <code>pageSize</code> as many times as you like, and the Ajax call will only happen once at the end of that sequence. It doesn't matter if your thread continually makes changes for longer than 1 millisecond, because re-evaluation won't start until you release your thread back to the JavaScript runtime.</p>
