<p><strong>Components</strong> are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:</p>
<ul>
<li>...can represent individual controls/widgets, or entire sections of your application</li>
<li>...contain their own view, and usually (but optionally) their own viewmodel</li>
<li>...can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</li>
<li>...can receive parameters, and optionally write back changes to them or invoke callbacks</li>
<li>...can be composed together (nested) or inherited from other components</li>
<li>...can easily be packaged for reuse across projects</li>
<li>...let you define your own conventions/logic for configuration and loading</li>
</ul>
<p>This pattern is beneficial for large applications, because it <strong>simplifies development</strong> through clear organization and encapsulation, and helps to <strong>improve runtime performance</strong> by incrementally loading your application code and templates as needed.</p>
<p><strong>Custom elements</strong> are an optional but convenient syntax for consuming components. Instead of needing placeholder <code>&lt;div&gt;</code>s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., <code>&lt;voting-button&gt;</code> or <code>&lt;product-editor&gt;</code>). Knockout takes care to ensure compatibility even with old browsers such as IE 6.</p>
<h3 id="example-a-like-dislike-widget">Example: A like/dislike widget</h3>
<p>To get started, you can register a component using <code>ko.components.register</code> (technically, registration is optional, but it&#39;s the easiest way to get started). A component definition specifies a <code>viewModel</code> and <code>template</code>. For example:</p>
<p><live-example params='id: "component-like"'></live-example></p>
<p><strong>Normally, you&#39;d load the view model and template from external files</strong> instead of declaring them inline like this. We&#39;ll get to that later.</p>
<p>Now, to use this component, you can reference it from any other view in your application, either using the <a href="#component-binding"><code>component</code> binding</a> or using a <a href="#component-custom-elements">custom element</a>. Here&#39;s a live example that uses it as a custom element:</p>
<p><live-example params='id: "component-overview"'></live-example></p>
<p>In this example, the component both displays and edits an observable property called <code>userRating</code> on the <code>Product</code> view model class.</p>
<h3 id="example-loading-the-like-dislike-widget-from-external-files-on-demand">Example: Loading the like/dislike widget from external files, on demand</h3>
<p>In most applications, you&#39;ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as <a href="http://requirejs.org/">require.js</a>, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.</p>
<p>Here&#39;s an example configuration:</p>
<pre><code class="lang-javascript">ko.components.register(&#39;like-or-dislike&#39;, {
    viewModel: { require: &#39;files/component-like-widget&#39; },
    template: { require: &#39;text!files/component-like-widget.html&#39; }
});
</code></pre>
<p><strong>Requirements</strong></p>
<p>For this to work, the files <a href="files/component-like-widget.js"><code>files/component-like-widget.js</code></a> and <a href="files/component-like-widget.html"><code>files/component-like-widget.html</code></a> need to exist. Check them out (and <em>view source</em> on the <code>.html</code> one) - as you&#39;ll see, this is cleaner and more convenient that including the code inline in the definition.</p>
<p>Also, you need to have referenced a suitable module loader library (such as <a href="http://requirejs.org/">require.js</a>) or implemented a <a href="component-loaders.html">custom component loader</a> that knows how to grab your files.</p>
<p><strong>Using the component</strong></p>
<p>Now <code>like-or-dislike</code> can be consumed in the same way as before, using either a <a href="#component-binding"><code>component</code> binding</a> or a <a href="#component-custom-elements">custom element</a>:</p>
<pre><code class="lang-html">&lt;ul data-bind=&quot;foreach: products&quot;&gt;
    &lt;li class=&quot;product&quot;&gt;
        &lt;strong data-bind=&quot;text: name&quot;&gt;&lt;/strong&gt;
        &lt;like-or-dislike params=&quot;value: userRating&quot;&gt;&lt;/like-or-dislike&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;button data-bind=&quot;click: addProduct&quot;&gt;Add a product&lt;/button&gt;
</code></pre>
<pre><code class="lang-javascript">function Product(name, rating) {
    this.name = name;
    this.userRating = ko.observable(rating || null);
}

function MyViewModel() {
    this.products = ko.observableArray(); // Start empty
}

MyViewModel.prototype.addProduct = function() {
    var name = &#39;Product &#39; + (this.products().length + 1);
    this.products.push(new Product(name));
};

ko.applyBindings(new MyViewModel());
</code></pre>
<p>If you open your browser developer tools&#39; <strong>Network</strong> inspector before your first click on <em>Add product</em>, you&#39;ll see that the component&#39;s <code>.js</code>/<code>.html</code> files are fetched on demand when first required, and thereafter retained for reuse.</p>
<h3 id="learn-more">Learn more</h3>
<p>More more detailed information, see:</p>
<ul>
<li><a href="#component-registration">Defining and registering components</a></li>
<li><a href="#component-binding">Using the <code>component</code> binding</a></li>
<li><a href="#component-custom-elements">Using custom elements</a></li>
<li><a href="#component-loaders">Advanced: Custom component loaders</a></li>
</ul>
