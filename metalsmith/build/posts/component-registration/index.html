<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Component registration</title>
  <meta name="description" content="It&#x27;s about saying »Hello« to the world.">
	<link rel="stylesheet" href="/assets/css/code.css">
</head>
<body>
  <header>
    <p>
      <a href="/">Home</a>
    </p>
  </header>
  <h1>Component registration</h1>

  <p>For Knockout to be able to load and instantiate your components, you must register them using <code class="lang-stylus">ko<span class="hljs-class">.components</span><span class="hljs-class">.register</span></code>, providing a configuration as described here.</p>
<p><em>Note: As an alternative, it's possible to implement a <a href="component-loaders.html">custom component loader</a> that fetches components by your own conventions instead of explicit configuration.</em></p>
<ul>
<li>[Table of contents injected here]
{:toc}</li>
</ul>
<h2 id="registering-components-as-a-viewmodel-template-pair">Registering components as a viewmodel/template pair</h2>
<p>You can register a component as follows:</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'some-component-name'</span>, {
    viewModel: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">see</span> <span class="hljs-attribute">below</span>&gt;</span>,
    template: <span class="hljs-tag">&lt;<span class="hljs-title">see</span> <span class="hljs-attribute">below</span>&gt;</span>
});
</span></code></pre>
<ul>
<li>The component <strong>name</strong> can be any nonempty string. It's recommended, but not mandatory, to use lowercase dash-separated strings (such as <code class="lang-applescript">your-component-<span class="hljs-property">name</span></code>) so that the component name is valid to use as a <a href="component-custom-elements.html">custom element</a> (such as <code class="lang-apache"><span class="hljs-tag">&lt;your-component-name&gt;</span></code>).</li>
<li><code>viewModel</code> is optional, and can take any of <a href="#specifying-a-viewmodel">the <code>viewModel</code> formats described below</a>.</li>
<li><code class="lang-cpp"><span class="hljs-keyword">template</span></code> is required, and can take any of <a href="#specifying-a-template">the <code class="lang-cpp"><span class="hljs-keyword">template</span></code> formats described below</a>.</li>
</ul>
<p>If no viewmodel is given, the component is treated as a simple block of HTML that will be bound to any parameters passed to the component.</p>
<h3 id="specifying-a-viewmodel">Specifying a viewmodel</h3>
<p>Viewmodels can be specified in any of the following forms:</p>
<h4 id="a-constructor-function">A constructor function</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SomeComponentViewModel</span>(<span class="hljs-params">params</span>) </span>{
    <span class="hljs-comment">// 'params' is an object whose key/value pairs are the parameters</span>
    <span class="hljs-comment">// passed from the component binding or custom element.</span>
    <span class="hljs-keyword">this</span>.someProperty = params.something;
}

SomeComponentViewModel.prototype.doSomething = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ ... };

ko.components.register(<span class="hljs-string">'my-component'</span>, {
    viewModel: SomeComponentViewModel,
    template: ...
});
</code></pre>
<p>Knockout will invoke your constructor once for each instance of the component, producing a separate viewmodel object for each. Properties on the resulting object or its prototype chain (e.g., <code>someProperty</code> and <code class="lang-bash"><span class="hljs-keyword">do</span>Something</code> in the example above) are available for binding in the component's view.</p>
<h4 id="a-shared-object-instance">A shared object instance</h4>
<p>If you want all instances of your component to share the same viewmodel object instance (which is not usually desirable):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sharedViewModelInstance = { ... };

ko.components.register(<span class="hljs-string">'my-component'</span>, {
    viewModel: { instance: sharedViewModelInstance },
    template: ...
});
</code></pre>
<p>Note that it's necessary to specify <code class="lang-css"><span class="hljs-tag">viewModel</span>: <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">instance</span>:<span class="hljs-value"> object </span></span></span>}</code>, and not just <code class="lang-http"><span class="hljs-attribute">viewModel</span>: <span class="hljs-string">object</span></code>. This differentiates from the other cases below.</p>
<h4 id="a-createviewmodel-factory-function">A <code>createViewModel</code> factory function</h4>
<p>If you want to run any setup logic on the associated element before it is bound to the viewmodel, or use arbitrary logic to decide which viewmodel class to instantiate:</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
    viewModel: {
        createViewModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params, componentInfo</span>) </span>{
            <span class="hljs-comment">// - 'params' is an object whose key/value pairs are the parameters</span>
            <span class="hljs-comment">//   passed from the component binding or custom element</span>
            <span class="hljs-comment">// - 'componentInfo.element' is the element the component is being</span>
            <span class="hljs-comment">//   injected into. When createViewModel is called, the template has</span>
            <span class="hljs-comment">//   already been injected into this element, but isn't yet bound.</span>
            <span class="hljs-comment">// - 'componentInfo.templateNodes' is an array containing any DOM</span>
            <span class="hljs-comment">//   nodes that have been supplied to the component. See below.</span>

            <span class="hljs-comment">// Return the desired view model instance, e.g.:</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyViewModel(params);
        }
    },
    template: ...
});
</code></pre>
<p>Note that, typically, it's best to perform direct DOM manipulation only through <a href="custom-bindings.html">custom bindings</a> rather than acting on <code class="lang-css"><span class="hljs-tag">componentInfo</span><span class="hljs-class">.element</span></code> from inside <code>createViewModel</code>. This leads to more modular, reusable code.</p>
<p>The <code class="lang-css"><span class="hljs-tag">componentInfo</span><span class="hljs-class">.templateNodes</span></code> array is useful if you want to build a component that accepts arbitrary markup to influence its output (for example, a grid, list, dialog, or tab set that injects supplied markup into itself). For a complete example, see <a href="component-custom-elements.html#passing-markup-into-components">passing markup into components</a>.</p>
<h4 id="an-amd-module-whose-value-describes-a-viewmodel">An AMD module whose value describes a viewmodel</h4>
<p>If you have an AMD loader (such as <a href="http://requirejs.org/">require.js</a>) already in your page, then you can use it to fetch a viewmodel. For more details about how this works, see <a href="#how-knockout-loads-components-via-amd">how Knockout loads components via AMD</a> below. Example:</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
  viewModel: { <span class="hljs-built_in">require</span>: <span class="hljs-string">'some/module/name'</span> },
  template: ...
});
</code></pre>
<p>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// AMD module whose value is a component viewmodel constructor</span>
define([<span class="hljs-string">'knockout'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ko</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyViewModel</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">return</span> MyViewModel;
});
</code></pre>
<p>... or a shared object instance, e.g.:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// AMD module whose value is a shared component viewmodel instance</span>
define([<span class="hljs-string">'knockout'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ko</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyViewModel</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">return</span> { instance: <span class="hljs-keyword">new</span> MyViewModel() };
});
</code></pre>
<p>... or a <code>createViewModel</code> function, e.g.:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// AMD module whose value is a 'createViewModel' function</span>
define([<span class="hljs-string">'knockout'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ko</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myViewModelFactory</span>(<span class="hljs-params">params, componentInfo</span>) </span>{
        <span class="hljs-comment">// return something</span>
    }

    <span class="hljs-keyword">return</span> { createViewModel: myViewModelFactory };
});
</code></pre>
<p>... or even, though it's unlikely you'd want to do this, a reference to a different AMD module, e.g.:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// AMD module whose value is a reference to a different AMD module,</span>
<span class="hljs-comment">// which in turn can be in any of these formats</span>
define([<span class="hljs-string">'knockout'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ko</span>) </span>{
    <span class="hljs-keyword">return</span> { <span class="hljs-built_in">module</span>: <span class="hljs-string">'some/other/module'</span> };
});
</code></pre>
<h3 id="specifying-a-template">Specifying a template</h3>
<p>Templates can be specified in any of the following forms. The most commonly useful are <a href="#an-existing-element-id">existing element IDs</a> and <a href="#an-amd-module-whose-value-describes-a-template">AMD modules</a>.</p>
<h4 id="an-existing-element-id">An existing element ID</h4>
<p>For example, the following element:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'my-component-template'</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">h1</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">'text: title'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">data-bind</span>=<span class="hljs-value">'click: doSomething'</span>&gt;</span>Click me right now<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<p>... can be used as the template for a component by specifying its ID:</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
    template: { element: <span class="hljs-string">'my-component-template'</span> },
    viewModel: ...
});
</code></pre>
<p>Note that only the nodes <em>inside</em> the specified element will be cloned into each instance of the component. The container element (in this example, the <code class="lang-apache"><span class="hljs-tag">&lt;template&gt;</span></code> element), will <em>not</em> be treated as part of the component template.</p>
<p>You're not limited to using <code class="lang-apache"><span class="hljs-tag">&lt;template&gt;</span></code> elements, but these are convenient (on browsers that support them) since they don't get rendered on their own. Any other element type works too.</p>
<h4 id="an-existing-element-instance">An existing element instance</h4>
<p>If you have a reference to a DOM element in your code, you can use it as a container for template markup:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> elemInstance = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'my-component-template'</span>);

ko.components.register(<span class="hljs-string">'my-component'</span>, {
    template: { element: elemInstance },
    viewModel: ...
});
</code></pre>
<p>Again, only the nodes <em>inside</em> the specified element will be cloned for use as the component's template.</p>
<h4 id="a-string-of-markup">A string of markup</h4>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
    template: <span class="hljs-string">'&lt;h1 data-bind="text: title"&gt;&lt;/h1&gt;\
               &lt;button data-bind="click: doSomething"&gt;Clickety&lt;/button&gt;'</span>,
    viewModel: ...
});
</code></pre>
<p>This is mainly useful when you're fetching the markup from somewhere programmatically (e.g., <a href="#a-recommended-amd-module-pattern">AMD - see below</a>), or as a build system output that packages components for distribution, since it's not very convenient to manually edit HTML as a JavaScript string literal.</p>
<h4 id="an-array-of-dom-nodes">An array of DOM nodes</h4>
<p>If you're building configurations programmatically and you have an array of DOM nodes, you can use them as a component template:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myNodes = [
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'first-node'</span>),
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'second-node'</span>),
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'third-node'</span>)
];

ko.components.register(<span class="hljs-string">'my-component'</span>, {
    template: myNodes,
    viewModel: ...
});
</code></pre>
<p>In this case, all the specified nodes (and their descendants) will be cloned and concatenated into each copy of the component that gets instantiated.</p>
<h4 id="a-document-fragment">A document fragment</h4>
<p>If you're building configurations programmatically and you have a <code>DocumentFragment</code> object, you can use it as a component template:</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
    template: someDocumentFragmentInstance,
    viewModel: ...
});
</code></pre>
<p>Since document fragments can have multiple top-level nodes, the <em>entire</em> document fragment (not just descendants of top-level nodes) is treated as the component template.</p>
<h4 id="an-amd-module-whose-value-describes-a-template">An AMD module whose value describes a template</h4>
<p>If you have an AMD loader (such as <a href="http://requirejs.org/">require.js</a>) already in your page, then you can use it to fetch a template. For more details about how this works, see <a href="#how-knockout-loads-components-via-amd">how Knockout loads components via AMD</a> below. Example:</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
    template: { <span class="hljs-built_in">require</span>: <span class="hljs-string">'some/template'</span> },
    viewModel: ...
});
</code></pre>
<p>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using <a href="http://requirejs.org/docs/api.html#text">require.js's text plugin</a>:</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
    template: { <span class="hljs-built_in">require</span>: <span class="hljs-string">'text!path/my-html-file.html'</span> },
    viewModel: ...
});
</code></pre>
<p>... or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.</p>
<h3 id="specifying-additional-component-options">Specifying additional component options</h3>
<p>As well as (or instead of) <code class="lang-cpp"><span class="hljs-keyword">template</span></code> and <code>viewModel</code>, your component configuration object can have arbitrary other properties. This configuration object is made available to any <a href="component-loaders.html">custom component loader</a> you may be using.</p>
<h4 id="controlling-synchronous-asynchronous-loading">Controlling synchronous/asynchronous loading</h4>
<p>If your component configuration has a boolean <code class="lang-vim"><span class="hljs-keyword">sync</span></code> property, Knockout uses this to determine whether the component is allowed to be loaded and injected synchronously. The default is <code class="lang-actionscript"><span class="hljs-literal">false</span></code> (i.e., forced to be asynchronous). For example,</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
    viewModel: { ... anything ... },
    template: { ... anything ... },
    sync: <span class="hljs-literal">true</span> <span class="hljs-comment">// Injects synchronously if already loaded, otherwise still async</span>
});
</code></pre>
<p><strong>Why is component loading normally forced to be asynchronous?</strong></p>
<p>Normally, Knockout ensures that component loading, and hence component injection, always completes asynchronously, because <em>sometimes it has no choice but to be asynchronous</em> (e.g., because it involves a request to the server). It does this even if a particular component instance could be injected synchronously (e.g., because the component definition was already loaded). This always-asynchronous policy is a matter of consistency, and is a well-established convention inherited from other modern asynchronous JavaScript technologies, such as AMD. The convention is a safe default --- it mitigates potential bugs where a developer might not account for the possibility of a typically-asynchronous process sometimes completing synchronously or vice-versa.</p>
<p><strong>Why would you ever enable synchronous loading?</strong></p>
<p>If you want to change the policy for a particular component, you can specify <code class="lang-groovy"><span class="hljs-string">sync:</span> <span class="hljs-literal">true</span></code> on that component's configuration. Then it might load asynchronously on first use, followed by synchronously on all subsequent uses. If you do this, then you need to account for this changeable behavior in any code that waits for components to load.</p>
<p>The benefit of <code class="lang-groovy"><span class="hljs-string">sync:</span> <span class="hljs-literal">true</span></code> is primarily that, if you're injecting a long list of copies of a certain component (e.g., inside a <code class="lang-cmake"><span class="hljs-keyword">foreach</span></code> binding), and if the component definition is already in memory due to previous usage, then all the new copies may be injected synchronously and cause only a single DOM reflow, which is preferable for performance especially on mobiles.</p>
<h2 id="how-knockout-loads-components-via-amd">How Knockout loads components via AMD</h2>
<p>When you load a viewmodel or template via <code class="lang-coffeescript"><span class="hljs-built_in">require</span></code> declarations, e.g.,</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, {
    viewModel: { <span class="hljs-built_in">require</span>: <span class="hljs-string">'some/module/name'</span> },
    template: { <span class="hljs-built_in">require</span>: <span class="hljs-string">'text!some-template.html'</span> }
});
</code></pre>
<p>...all Knockout does is call <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">([<span class="hljs-string">'some/module/name'</span>], callback)</span></span></code> and <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">([<span class="hljs-string">'text!some-template.html'</span>], callback)</span></span></code>, and uses the asynchronously-returned objects as the viewmodel and template definitions. So,</p>
<ul>
<li><strong>This does not take a strict dependency on <a href="http://requirejs.org/">require.js</a></strong> or any other particular module loader. <em>Any</em> module loader that provides an AMD-style <code class="lang-coffeescript"><span class="hljs-built_in">require</span></code> API will do. If you want to integrate with a module loader whose API is different, you can implement a <a href="component-loaders.html">custom component loader</a>.</li>
<li><strong>Knockout does not interpret the module name</strong> in any way - it merely passes it through to <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">()</span></span></code>. So of course Knockout does not know or care about where your module files are loaded from. That's up to your AMD loader and how you've configured it.</li>
<li><strong>Knockout doesn't know or care whether your AMD modules are anonymous or not</strong>. Typically we find it's most convenient for components to be defined as anonymous modules, but that concern is entirely separate from KO.</li>
</ul>
<h4 id="amd-modules-are-loaded-only-on-demand">AMD modules are loaded only on demand</h4>
<p>Knockout does not call <code class="lang-stylus"><span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">([moduleName], ...)</span></span></code> until your component is being instantiated. This is how components get loaded on demand, not up front.</p>
<p>For example, if your component is inside some other element with an <a href="if-binding.html"><code class="lang-actionscript"><span class="hljs-keyword">if</span></code> binding</a> (or another control flow binding), then it will not cause the AMD module to be loaded until the <code class="lang-actionscript"><span class="hljs-keyword">if</span></code> condition is true. Of course, if the AMD module was already loaded (e.g., in a preloaded bundle) then the <code class="lang-coffeescript"><span class="hljs-built_in">require</span></code> call will not trigger any additional HTTP requests, so you can control what is preloaded and what is loaded on demand.</p>
<h2 id="registering-components-as-a-single-amd-module">Registering components as a single AMD module</h2>
<p>For even better encapsulation, you can package a component into a single self-describing AMD module. Then you can reference a component as simply as:</p>
<pre><code class="lang-javascript">ko.components.register(<span class="hljs-string">'my-component'</span>, { <span class="hljs-built_in">require</span>: <span class="hljs-string">'some/module'</span> });
</code></pre>
<p>Notice that no viewmodel/template pair is specified. The AMD module itself can provide a viewmodel/template pair, using any of the definition formats listed above. For example, the file <code class="lang-crystal">some/<span class="hljs-class"><span class="hljs-keyword">module</span>.<span class="hljs-title">js</span></span></code> could be declared as:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// AMD module 'some/module.js' encapsulating the configuration for a component</span>
define([<span class="hljs-string">'knockout'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ko</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponentViewModel</span>(<span class="hljs-params">params</span>) </span>{
        <span class="hljs-keyword">this</span>.personName = ko.observable(params.name);
    }

    <span class="hljs-keyword">return</span> {
        viewModel: MyComponentViewModel,
        template: <span class="hljs-string">'The name is &lt;strong data-bind="text: personName"&gt;&lt;/strong&gt;'</span>
    };
});
</code></pre>
<h3 id="a-recommended-amd-module-pattern">A recommended AMD module pattern</h3>
<p>What tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.</p>
<p>For example, if the following is in a file at <code class="lang-applescript">path/<span class="hljs-keyword">my</span>-component.js</code>,</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Recommended AMD module pattern for a Knockout component that:</span>
<span class="hljs-comment">//  - Can be referenced with just a single 'require' declaration</span>
<span class="hljs-comment">//  - Can be included in a bundle using the r.js optimizer</span>
define([<span class="hljs-string">'knockout'</span>, <span class="hljs-string">'text!./my-component.html'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ko, htmlString</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponentViewModel</span>(<span class="hljs-params">params</span>) </span>{
        <span class="hljs-comment">// Set up properties, etc.</span>
    }

    <span class="hljs-comment">// Use prototype to declare any public methods</span>
    MyComponentViewModel.prototype.doSomething = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ ... };

    <span class="hljs-comment">// Return component definition</span>
    <span class="hljs-keyword">return</span> { viewModel: MyComponentViewModel, template: htmlString };
});
</code></pre>
<p>... and the template markup is in the file <code class="lang-applescript">path/<span class="hljs-keyword">my</span>-component.html</code>, then you have these benefits:</p>
<ul>
<li>Applications can reference this trivially, i.e., <code class="lang-less"><span class="hljs-tag">ko</span><span class="hljs-class">.components</span><span class="hljs-class">.register</span>(<span class="hljs-string">'my-component'</span>, { <span class="hljs-attribute">require</span>: <span class="hljs-string">'path/my-component'</span> });</code></li>
<li>You only need two files for the component - a viewmodel (<code class="lang-applescript">path/<span class="hljs-keyword">my</span>-component.js</code>) and a template (<code class="lang-applescript">path/<span class="hljs-keyword">my</span>-component.html</code>) - which is a very natural arrangement during development.</li>
<li>Since the dependency on the template is explicitly stated in the <code class="lang-lasso"><span class="hljs-class"><span class="hljs-keyword">define</span></span></code> call, this automatically works with the <a href="http://requirejs.org/docs/optimization.html"><code class="lang-css"><span class="hljs-tag">r</span><span class="hljs-class">.js</span></code> optimizer</a> or similar bundling tools. The entire component - viewmodel plus template - can therefore trivially be included in a bundle file during a build step.<ul>
<li>Note: Since the r.js optimizer is very flexible, it has a lot of options and can take some time to set up. You may want to start from a ready-made example of Knockout components being optimized through r.js, in which case see <a href="http://yeoman.io/">Yeoman</a> and the <a href="https://www.npmjs.org/package/generator-ko">generator-ko</a> generator. Blog post coming soon.</li>
</ul>
</li>
</ul>


  <footer>
    <p>Generated with Metalsmith &mdash; <a href="http://metalsmith.io">http://metalsmith.io</a></p>
  </footer>

</body>
</html>
